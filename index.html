<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸŒ¾ Robo Farm</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323:wght@400&family=Silkscreen&display=swap" rel="stylesheet">
<script src="settings.js"></script>
<style>
:root {
  --gold: #f5c842;
  --gold-dim: #c9973a;
  --ui-bg: rgba(18, 14, 8, 0.92);
  --ui-border: #5a3e1a;
  --ui-border-bright: #c9973a;
  --text: #f0e8d0;
  --text-dim: #998877;
  --green: #4a9c3f;
  --red: #c44040;
  --blue: #3a7abb;
  --panel-bg: rgba(12, 10, 5, 0.96);
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { overflow: hidden; background: #1a2010; font-family: 'VT323', monospace; cursor: none; }
body.show-system-cursor { cursor: default; }
canvas#game { display: block; position: fixed; top: 0; left: 0; image-rendering: pixelated; }
canvas#cursor-canvas { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1000; }
body.show-system-cursor canvas#cursor-canvas { display: none; }

/* â”€â”€â”€ TOP BAR â”€â”€â”€ */
#topbar {
  position: fixed; top: 0; left: 0; right: 0; height: 44px;
  background: var(--ui-bg); border-bottom: 2px solid var(--ui-border);
  display: flex; align-items: center; padding: 0 12px; gap: 16px; z-index: 200;
  font-family: 'Press Start 2P', monospace; font-size: 8px;
}
#game-title { color: var(--gold); letter-spacing: 1px; white-space: nowrap; }
.stat-block { display: flex; align-items: center; gap: 5px; color: var(--text); }
.stat-block .val { color: var(--gold); min-width: 40px; }
#topbar-right { margin-left: auto; display: flex; gap: 6px; }
.top-btn {
  background: var(--ui-bg); border: 1px solid var(--ui-border);
  color: var(--text); font-family: 'Press Start 2P', monospace; font-size: 7px;
  padding: 5px 8px; cursor: pointer; transition: all 0.1s;
}
.top-btn:hover { border-color: var(--gold); color: var(--gold); background: rgba(200,150,50,0.15); }
.top-btn.active { border-color: var(--gold); color: var(--gold); background: rgba(200,150,50,0.2); }

/* â”€â”€â”€ HOTBAR â”€â”€â”€ */
#hotbar {
  position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 4px; z-index: 200;
  background: var(--ui-bg); border: 2px solid var(--ui-border);
  padding: 6px 8px; border-radius: 2px;
}
.hslot {
  width: 44px; height: 44px; border: 2px solid #3a2a0e;
  background: rgba(0,0,0,0.5); display: flex; flex-direction: column;
  align-items: center; justify-content: center; cursor: pointer;
  position: relative; transition: border-color 0.1s;
  font-size: 20px; color: var(--text);
}
.hslot:hover { border-color: var(--ui-border-bright); }
.hslot.selected { border-color: var(--gold); box-shadow: 0 0 8px rgba(245,200,66,0.4); }
.hslot .key-hint { position: absolute; top: 1px; left: 3px; font-family: 'Press Start 2P', monospace; font-size: 5px; color: var(--text-dim); }
.hslot .count { position: absolute; bottom: 1px; right: 3px; font-family: 'Press Start 2P', monospace; font-size: 6px; color: var(--gold); }
.hslot .lbl { font-size: 8px; font-family: 'VT323', monospace; color: var(--text-dim); margin-top: -2px; }

/* â”€â”€â”€ MODALS â”€â”€â”€ */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 500;
  display: flex; align-items: center; justify-content: center;
}
.modal-overlay.hidden { display: none; }
.modal {
  background: var(--panel-bg); border: 2px solid var(--ui-border-bright);
  min-width: 480px; max-width: 700px; max-height: 80vh; overflow: hidden;
  display: flex; flex-direction: column;
}
.modal-header {
  background: rgba(90,62,26,0.5); padding: 10px 14px;
  display: flex; align-items: center; justify-content: space-between;
  border-bottom: 1px solid var(--ui-border);
}
.modal-title { color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 10px; }
.modal-close { color: var(--text-dim); font-size: 20px; cursor: pointer; font-family: 'VT323', monospace; }
.modal-close:hover { color: var(--red); }
.modal-body { padding: 14px; overflow-y: auto; flex: 1; }
.modal-tabs { display: flex; border-bottom: 1px solid var(--ui-border); margin-bottom: 12px; }
.tab-btn {
  padding: 6px 14px; cursor: pointer; color: var(--text-dim);
  font-family: 'Press Start 2P', monospace; font-size: 8px;
  border: none; background: transparent;
  border-bottom: 2px solid transparent; margin-bottom: -1px;
}
.tab-btn:hover { color: var(--text); }
.tab-btn.active { color: var(--gold); border-bottom-color: var(--gold); }
.tab-content { display: none; }
.tab-content.active { display: block; }

/* â”€â”€â”€ SHOP â”€â”€â”€ */
.shop-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
.shop-item {
  border: 1px solid var(--ui-border); padding: 10px; text-align: center;
  cursor: pointer; transition: all 0.15s; background: rgba(0,0,0,0.3);
}
.shop-item:hover { border-color: var(--gold); background: rgba(200,150,50,0.1); }
.shop-item .item-emoji { font-size: 28px; display: block; margin-bottom: 4px; }
.shop-item .item-name { color: var(--text); font-size: 14px; display: block; }
.shop-item .item-price { color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 8px; display: block; margin-top: 4px; }
.shop-item .item-qty { color: var(--text-dim); font-size: 12px; margin-top: 2px; display: block; }
.sell-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.sell-item { border: 1px solid var(--ui-border); padding: 8px; background: rgba(0,0,0,0.3); display: flex; align-items: center; gap: 8px; }
.sell-item .item-emoji { font-size: 22px; }
.sell-info { flex: 1; }
.sell-info .name { color: var(--text); font-size: 16px; }
.sell-info .count { color: var(--text-dim); font-size: 13px; }
.sell-btn { background: var(--green); border: none; color: white; font-family: 'Press Start 2P', monospace; font-size: 7px; padding: 5px 8px; cursor: pointer; }
.sell-btn:hover { opacity: 0.85; }
.sell-all-btn { background: var(--gold-dim); border: none; color: #1a1000; font-family: 'Press Start 2P', monospace; font-size: 7px; padding: 5px 8px; cursor: pointer; margin-top: 8px; width: 100%; }

/* â”€â”€â”€ ROBOT PANEL â”€â”€â”€ */
.robot-list-item {
  border: 1px solid var(--ui-border); padding: 8px 10px; margin-bottom: 6px;
  cursor: pointer; display: flex; align-items: center; gap: 10px; transition: border-color 0.1s;
}
.robot-list-item:hover, .robot-list-item.selected { border-color: var(--gold); }
.robot-icon { font-size: 24px; }
.robot-info { flex: 1; }
.robot-name { color: var(--text); font-size: 16px; }
.robot-status { color: var(--text-dim); font-size: 13px; }
.battery-bar { height: 4px; background: #222; margin-top: 4px; border: 1px solid #333; }
.battery-fill { height: 100%; background: var(--green); transition: width 0.3s; }
.battery-fill.low { background: var(--red); }
.robot-detail-panel { border: 1px solid var(--ui-border); padding: 12px; margin-top: 8px; background: rgba(0,0,0,0.3); display: none; }
.robot-detail-panel.visible { display: block; }
.detail-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.detail-label { color: var(--text-dim); font-family: 'Press Start 2P', monospace; font-size: 7px; width: 100px; }
.detail-value { color: var(--text); font-size: 15px; flex: 1; }
select.game-select, input.game-input {
  background: rgba(0,0,0,0.5); border: 1px solid var(--ui-border);
  color: var(--text); font-family: 'VT323', monospace; font-size: 16px; padding: 3px 6px; width: 100%;
}
select.game-select:focus, input.game-input:focus { border-color: var(--gold); outline: none; }
textarea.code-area {
  background: #0a0c08; border: 1px solid var(--ui-border);
  color: #7fff7f; font-family: 'Courier New', monospace; font-size: 12px;
  padding: 8px; width: 100%; height: 180px; resize: vertical; line-height: 1.5;
}
textarea.code-area:focus { border-color: var(--green); outline: none; }
.code-error { color: var(--red); font-size: 13px; margin-top: 4px; font-family: 'VT323', monospace; }

/* â”€â”€â”€ DOCS â”€â”€â”€ */
.docs-body { color: var(--text); font-size: 16px; line-height: 1.7; }
.docs-body h2 { color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 9px; margin: 16px 0 8px; }
.docs-body h3 { color: var(--gold-dim); font-family: 'Press Start 2P', monospace; font-size: 7px; margin: 12px 0 6px; }
.docs-body p { margin-bottom: 8px; color: var(--text-dim); }
.docs-body p strong { color: var(--text); }
.docs-body code { background: rgba(0,0,0,0.5); color: #7fff7f; padding: 1px 5px; font-family: 'Courier New', monospace; font-size: 12px; }
.docs-body .tip { border-left: 3px solid var(--gold); padding: 6px 10px; margin: 8px 0; background: rgba(245,200,66,0.07); }
.docs-body .key { display: inline-block; background: #2a2010; border: 1px solid var(--ui-border); padding: 1px 5px; font-family: 'Press Start 2P', monospace; font-size: 7px; }

/* â”€â”€â”€ NOTIFICATIONS â”€â”€â”€ */
#notifications { position: fixed; top: 56px; right: 12px; z-index: 600; display: flex; flex-direction: column; gap: 4px; pointer-events: none; }
.notif {
  background: var(--ui-bg); border: 1px solid var(--ui-border-bright);
  color: var(--text); font-size: 15px; padding: 7px 12px;
  animation: notifIn 0.2s ease; max-width: 260px;
}
.notif.fade { animation: notifOut 0.4s ease forwards; }
@keyframes notifIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
@keyframes notifOut { to { opacity: 0; transform: translateX(20px); } }

/* â”€â”€â”€ ROBOT TOOLTIP â”€â”€â”€ */
#robot-tooltip {
  position: fixed; z-index: 300; pointer-events: none;
  background: var(--ui-bg); border: 1px solid var(--ui-border-bright);
  padding: 6px 10px; font-size: 13px; color: var(--text); display: none;
}

/* â”€â”€â”€ GAME BUTTONS â”€â”€â”€ */
.game-btn {
  background: rgba(90,62,26,0.7); border: 1px solid var(--ui-border);
  color: var(--text); font-family: 'Press Start 2P', monospace; font-size: 7px;
  padding: 7px 10px; cursor: pointer; transition: all 0.1s;
}
.game-btn:hover { border-color: var(--gold); color: var(--gold); }
.game-btn.primary { background: rgba(100,70,20,0.8); border-color: var(--gold-dim); color: var(--gold); }
.game-btn.danger { border-color: #8a3030; color: #ff8080; }
.game-btn.success { border-color: #306830; color: #80ff80; }

/* â”€â”€â”€ ASSIGN OVERLAY â”€â”€â”€ */
#assign-overlay {
  position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
  background: var(--ui-bg); border: 2px solid var(--gold);
  padding: 10px 16px; z-index: 300; display: none;
  font-family: 'Press Start 2P', monospace; font-size: 8px; color: var(--gold);
  text-align: center;
}
#assign-overlay.visible { display: block; }

/* â”€â”€â”€ CROP INFO TOOLTIP â”€â”€â”€ */
#crop-tooltip {
  position: fixed; z-index: 400; pointer-events: none;
  background: var(--panel-bg); border: 1px solid var(--ui-border-bright);
  padding: 7px 11px; font-size: 13px; color: var(--text);
  display: none; min-width: 130px;
}
#crop-tooltip .ct-name { color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 7px; margin-bottom: 5px; }
#crop-tooltip .ct-bar { height: 3px; background: #222; margin-top: 3px; border: 1px solid #333; }
#crop-tooltip .ct-fill { height: 100%; background: var(--green); transition: width 0.2s; }
#crop-tooltip .ct-ready { color: #7fff7f; font-family: 'Press Start 2P', monospace; font-size: 6px; margin-top: 5px; animation: pulse 1s infinite; }
@keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.5; } }

/* â”€â”€â”€ CODE EDITOR TOOLBAR â”€â”€â”€ */
.code-toolbar {
  display: flex; gap: 5px; margin-bottom: 6px; flex-wrap: wrap; align-items: center;
}
.code-tool-btn {
  background: rgba(0,0,0,0.4); border: 1px solid var(--ui-border);
  color: var(--text-dim); font-family: 'Press Start 2P', monospace; font-size: 6px;
  padding: 4px 7px; cursor: pointer; transition: all 0.1s;
}
.code-tool-btn:hover { border-color: var(--gold); color: var(--gold); }
.code-tool-btn.green { border-color: #2a5a2a; color: #80ff80; }
.code-tool-btn.green:hover { background: rgba(0,80,0,0.3); }
.code-security-badge {
  margin-left: auto; font-family: 'Press Start 2P', monospace; font-size: 5px;
  color: #80ff80; border: 1px solid #2a5a2a; padding: 3px 6px;
  background: rgba(0,40,0,0.4);
}
.code-template-menu {
  display: none; position: absolute; background: var(--panel-bg);
  border: 1px solid var(--ui-border-bright); z-index: 600;
  min-width: 200px;
}
.code-template-menu.visible { display: block; }
.code-template-item {
  padding: 8px 12px; cursor: pointer; color: var(--text); font-size: 14px;
  border-bottom: 1px solid var(--ui-border);
}
.code-template-item:hover { background: rgba(200,150,50,0.1); color: var(--gold); }
.code-template-item .tpl-desc { color: var(--text-dim); font-size: 11px; display: block; margin-top: 2px; }

/* â”€â”€â”€ API REFERENCE COLLAPSIBLE â”€â”€â”€ */
.api-ref-toggle {
  color: var(--text-dim); font-family: 'Press Start 2P', monospace; font-size: 6px;
  cursor: pointer; padding: 4px 0; margin-top: 4px; display: flex; gap: 6px; align-items: center;
}
.api-ref-toggle:hover { color: var(--gold-dim); }
.api-ref-body {
  display: none; background: rgba(0,0,0,0.3); border: 1px solid var(--ui-border);
  padding: 8px; margin-top: 4px; font-size: 12px; color: #7fff7f;
  font-family: 'Courier New', monospace; line-height: 1.8; max-height: 160px; overflow-y: auto;
}
.api-ref-body.visible { display: block; }

/* â”€â”€â”€ FILES MODAL â”€â”€â”€ */
.files-card {
  border: 1px solid var(--ui-border); padding: 16px; background: rgba(0,0,0,0.3);
  display: flex; flex-direction: column; gap: 8px;
}
.files-card-title { color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 8px; margin-bottom: 4px; }
.files-card-desc { color: var(--text-dim); font-size: 14px; line-height: 1.5; }
.files-card .big-btn {
  background: rgba(90,62,26,0.7); border: 1px solid var(--gold-dim);
  color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 8px;
  padding: 10px 14px; cursor: pointer; transition: all 0.15s; text-align: center;
}
.files-card .big-btn:hover { background: rgba(140,100,30,0.5); border-color: var(--gold); }
.files-card .big-btn.import-btn { border-color: #3a6a3a; color: #80ff80; background: rgba(20,60,20,0.5); }
.files-card .big-btn.import-btn:hover { background: rgba(20,80,20,0.5); }
.files-divider { border: none; border-top: 1px solid var(--ui-border); margin: 6px 0; }
#import-file-input { display: none; }
#import-robot-file-input { display: none; }

/* â”€â”€â”€ CHANGELOG MODAL â”€â”€â”€ */
.changelog-body { color: var(--text); font-family: 'VT323', monospace; }
.changelog-version {
  color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 9px;
  margin-bottom: 4px;
}
.changelog-subtitle { color: var(--text-dim); font-size: 15px; margin-bottom: 14px; }
.changelog-section { margin-bottom: 16px; }
.changelog-section-title {
  color: var(--gold-dim); font-family: 'Press Start 2P', monospace; font-size: 7px;
  margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid var(--ui-border);
}
.changelog-entry { display: flex; gap: 10px; margin-bottom: 8px; align-items: flex-start; }
.changelog-star { color: var(--gold); font-size: 18px; line-height: 1; flex-shrink: 0; }
.changelog-text { font-size: 16px; color: var(--text-dim); line-height: 1.4; }
.changelog-text strong { color: var(--text); }
.changelog-text em { color: var(--green); font-style: normal; }
.changelog-footer {
  text-align: center; color: var(--text-dim); font-size: 14px; padding-top: 12px;
  border-top: 1px solid var(--ui-border); margin-top: 12px;
}

/* â”€â”€â”€ SAVE FLASH â”€â”€â”€ */
#save-flash {
  position: fixed; top: 50px; right: 12px; z-index: 601; pointer-events: none;
  font-family: 'Press Start 2P', monospace; font-size: 7px; color: #80ff80;
  opacity: 0; transition: opacity 0.3s;
}
#save-flash.show { opacity: 1; }

/* â”€â”€â”€ MILESTONE BANNER â”€â”€â”€ */
#milestone-banner {
  position: fixed; top: 56px; left: 50%; transform: translateX(-50%);
  background: rgba(18,14,8,0.96); border: 2px solid var(--gold);
  padding: 10px 22px; z-index: 700; pointer-events: none;
  font-family: 'Press Start 2P', monospace; font-size: 8px; color: var(--gold);
  text-align: center; opacity: 0; transition: opacity 0.4s;
}
#milestone-banner.show { opacity: 1; }
#milestone-banner .msub { color: var(--text-dim); font-size: 10px; margin-top: 5px; font-family: 'VT323', monospace; }

/* â”€â”€â”€ DAY TRANSITION â”€â”€â”€ */
#day-banner {
  position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
  z-index: 800; pointer-events: none; opacity: 0;
  transition: opacity 0.5s;
}
#day-banner.show { opacity: 1; }
#day-banner-inner {
  background: var(--ui-bg); border: 2px solid var(--gold);
  padding: 20px 40px; text-align: center;
}
#day-banner-text { font-family: 'Press Start 2P', monospace; color: var(--gold); font-size: 16px; }
#day-banner-sub { color: var(--text-dim); font-size: 18px; margin-top: 6px; }
</style>
</head>
<body>

<!-- Canvases -->
<canvas id="game"></canvas>
<canvas id="cursor-canvas"></canvas>

<!-- Top Bar -->
<div id="topbar">
  <div id="game-title">ğŸŒ¾ ROBO FARM</div>
  <div class="stat-block">ğŸ’° <span id="stat-coins" class="val">250</span></div>
  <div class="stat-block">ğŸ“… Day <span id="stat-day" class="val">1</span></div>
  <div class="stat-block" id="stat-season-block">ğŸŒ¸ <span id="stat-season" class="val">Spring</span></div>
  <div class="stat-block">â° <span id="stat-time" class="val">Morning</span></div>
  <div id="topbar-right">
    <button class="top-btn" onclick="openModal('shop')">ğŸª Shop</button>
    <button class="top-btn" onclick="openModal('robots')">ğŸ¤– Robots</button>
    <button class="top-btn" onclick="openModal('docs')">ğŸ“– Docs</button>
    <button class="top-btn" onclick="openModal('files')" title="World Backup & Import">ğŸ“ Files</button>
    <button class="top-btn" onclick="saveGame()" title="Save Game">ğŸ’¾</button>
    <button class="top-btn" onclick="openModal('changelog')" style="border-color:#3a5a3a;color:#80cc80">ğŸ“‹ v0.2</button>
  </div>
</div>
<div id="save-flash" style="position:fixed;top:50px;right:12px;z-index:601;pointer-events:none;font-family:'Press Start 2P',monospace;font-size:7px;color:#80ff80;opacity:0;transition:opacity 0.3s">âœ“ saved</div>
<div id="milestone-banner" style="position:fixed;top:56px;left:50%;transform:translateX(-50%);background:rgba(18,14,8,0.96);border:2px solid var(--gold);padding:10px 22px;z-index:700;pointer-events:none;font-family:'Press Start 2P',monospace;font-size:8px;color:var(--gold);text-align:center;opacity:0;transition:opacity 0.4s"><div id="milestone-text"></div><div id="milestone-sub" style="color:var(--text-dim);font-size:10px;margin-top:5px;font-family:'VT323',monospace"></div></div>

<!-- Hotbar -->
<div id="hotbar">
  <div class="hslot selected" data-tool="hand" onclick="selectTool('hand')">
    <span class="key-hint">1</span>âœ‹<span class="lbl">Hand</span>
  </div>
  <div class="hslot" data-tool="hoe" onclick="selectTool('hoe')">
    <span class="key-hint">2</span>â›ï¸<span class="lbl">Hoe</span>
  </div>
  <div class="hslot" data-tool="water" onclick="selectTool('water')">
    <span class="key-hint">3</span>ğŸ’§<span class="lbl">Water</span>
  </div>
  <div class="hslot seed-slot" data-tool="wheat" onclick="selectTool('wheat')">
    <span class="key-hint">4</span>ğŸŒ¾<span class="lbl">Wheat</span><span class="count" id="cnt-wheat">0</span>
  </div>
  <div class="hslot seed-slot" data-tool="carrot" onclick="selectTool('carrot')">
    <span class="key-hint">5</span>ğŸ¥•<span class="lbl">Carrot</span><span class="count" id="cnt-carrot">0</span>
  </div>
  <div class="hslot seed-slot" data-tool="corn" onclick="selectTool('corn')">
    <span class="key-hint">6</span>ğŸŒ½<span class="lbl">Corn</span><span class="count" id="cnt-corn">0</span>
  </div>
  <div class="hslot seed-slot" data-tool="sunflower" onclick="selectTool('sunflower')">
    <span class="key-hint">7</span>ğŸŒ»<span class="lbl">Sun</span><span class="count" id="cnt-sunflower">0</span>
  </div>
  <div class="hslot seed-slot" data-tool="potato" onclick="selectTool('potato')">
    <span class="key-hint">8</span>ğŸ¥”<span class="lbl">Potato</span><span class="count" id="cnt-potato">0</span>
  </div>
  <div class="hslot" data-tool="robot_place" onclick="selectTool('robot_place')">
    <span class="key-hint">9</span>ğŸ¤–<span class="lbl">Bot</span>
  </div>
</div>

<!-- Assign Overlay -->
<div id="assign-overlay">ğŸ¯ CLICK A TILE TO SET WORK AREA<br><small style="font-size:6px;margin-top:4px;display:block">ESC to cancel</small></div>

<!-- Crop Info Tooltip -->
<div id="crop-tooltip"><div class="ct-name" id="ct-name"></div><div id="ct-stage" style="color:var(--text-dim);font-size:13px"></div><div class="ct-bar"><div class="ct-fill" id="ct-fill"></div></div><div id="ct-ready" class="ct-ready" style="display:none">âœ¦ READY TO HARVEST!</div></div>

<!-- Hidden file inputs -->
<input type="file" id="import-file-input" accept=".js" onchange="handleWorldImportFile(this)">
<input type="file" id="import-robot-file-input" accept=".js" onchange="handleRobotImportFile(this)">

<!-- Robot Tooltip -->
<div id="robot-tooltip"></div>

<!-- Day Banner -->
<div id="day-banner"><div id="day-banner-inner"><div id="day-banner-text"></div><div id="day-banner-sub"></div></div></div>

<!-- Notifications -->
<div id="notifications"></div>

<!-- SHOP MODAL -->
<div class="modal-overlay hidden" id="modal-shop">
<div class="modal" style="width:600px">
  <div class="modal-header">
    <span class="modal-title">ğŸª MARKET & SHOP</span>
    <span class="modal-close" onclick="closeModal('shop')">âœ•</span>
  </div>
  <div class="modal-body">
    <div class="modal-tabs">
      <button class="tab-btn active" onclick="switchTab('shop','buy')">Buy Seeds</button>
      <button class="tab-btn" onclick="switchTab('shop','equipment')">Equipment</button>
      <button class="tab-btn" onclick="switchTab('shop','sell')">Sell Crops</button>
    </div>
    <div id="shop-tab-buy" class="tab-content active">
      <div style="color:var(--text-dim);font-size:13px;margin-bottom:10px">Click a seed to buy 5 at a time. Hold Shift to buy 1.</div>
      <div class="shop-grid" id="seed-shop-grid"></div>
    </div>
    <div id="shop-tab-equipment" class="tab-content">
      <div class="shop-grid">
        <div class="shop-item" onclick="buyRobot()">
          <span class="item-emoji">ğŸ¤–</span>
          <span class="item-name">Robot</span>
          <span class="item-price" id="robot-price-display">200 coins</span>
          <span class="item-qty" id="robot-count-display">Owned: 0</span>
        </div>
      </div>
      <div style="color:var(--text-dim);font-size:13px;margin-top:12px;padding:8px;border:1px solid var(--ui-border)">
        ğŸ¤– Robots automate your farm! Place them with the Robot tool (key 9), then click them to assign tasks. You can even write custom AI in <code>settings.js</code>!
      </div>
    </div>
    <div id="shop-tab-sell" class="tab-content">
      <div style="color:var(--text-dim);font-size:13px;margin-bottom:10px">Sell your harvested crops here. Sell all at once for the best value!</div>
      <div class="sell-grid" id="sell-grid"></div>
      <button class="sell-all-btn" onclick="sellAll()">ğŸ’° SELL ALL CROPS</button>
    </div>
  </div>
</div>
</div>

<!-- ROBOTS MODAL -->
<div class="modal-overlay hidden" id="modal-robots">
<div class="modal" style="width:580px">
  <div class="modal-header">
    <span class="modal-title">ğŸ¤– ROBOT MANAGER</span>
    <span class="modal-close" onclick="closeModal('robots')">âœ•</span>
  </div>
  <div class="modal-body">
    <div style="color:var(--text-dim);font-size:13px;margin-bottom:10px">Select a robot to configure it. Or use the Robot tool to place/select them on the map!</div>
    <div id="robot-list"></div>
    <div id="robot-config-panel" class="robot-detail-panel">
      <div style="color:var(--gold);font-family:'Press Start 2P',monospace;font-size:9px;margin-bottom:10px" id="config-robot-name">BOT-1</div>
      <div class="detail-row">
        <span class="detail-label">BEHAVIOR</span>
        <select class="game-select" id="robot-behavior-select" onchange="applyRobotBehavior()"></select>
      </div>
      <div class="detail-row">
        <span class="detail-label">PLANT CROP</span>
        <select class="game-select" id="robot-crop-select" onchange="applyRobotCrop()">
          <option value="wheat">ğŸŒ¾ Wheat</option>
          <option value="carrot">ğŸ¥• Carrot</option>
          <option value="corn">ğŸŒ½ Corn</option>
          <option value="sunflower">ğŸŒ» Sunflower</option>
          <option value="potato">ğŸ¥” Potato</option>
          <option value="tomato">ğŸ… Tomato</option>
        </select>
      </div>
      <div class="detail-row">
        <span class="detail-label">WORK AREA</span>
        <span class="detail-value" id="robot-area-display" style="color:var(--text-dim);font-size:14px">Not set</span>
        <button class="game-btn" onclick="startSetWorkArea()" style="font-size:7px">Set Area</button>
      </div>
      <div style="margin-top:10px">
        <div style="color:var(--gold-dim);font-family:'Press Start 2P',monospace;font-size:7px;margin-bottom:6px">âš¡ CUSTOM JS CODE (optional)</div>
        <div style="color:var(--text-dim);font-size:12px;margin-bottom:6px">Override with your own behavior. Leave blank to use the selected behavior above.</div>
        <div class="code-toolbar" style="position:relative">
          <div style="position:relative">
            <button class="code-tool-btn" onclick="toggleTemplateMenu()">ğŸ“‹ Templates â–¾</button>
            <div class="code-template-menu" id="template-menu">
              <div class="code-template-item" onclick="applyTemplate('blank')">Blank <span class="tpl-desc">Clean slate. Write your own!</span></div>
              <div class="code-template-item" onclick="applyTemplate('waterer')">ğŸ’§ Smart Waterer <span class="tpl-desc">Finds thirsty crops and waters them</span></div>
              <div class="code-template-item" onclick="applyTemplate('fullcycle')">â™»ï¸ Full Cycle <span class="tpl-desc">Harvest â†’ Water â†’ Plant loop</span></div>
              <div class="code-template-item" onclick="applyTemplate('zone')">ğŸ“ Zone Farmer <span class="tpl-desc">Full cycle within assigned work area</span></div>
              <div class="code-template-item" onclick="applyTemplate('patrol')">ğŸ” Scout <span class="tpl-desc">Wanders area, waters anything needy</span></div>
            </div>
          </div>
          <button class="code-tool-btn" onclick="document.getElementById('import-robot-file-input').click()">ğŸ“¥ Import .js</button>
          <button class="code-tool-btn green" onclick="exportRobotCode()">ğŸ“¤ Export .js</button>
          <div class="code-security-badge">ğŸ”’ SANDBOX</div>
        </div>
        <div class="api-ref-toggle" onclick="toggleApiRef()"><span id="api-ref-arrow">â–¶</span> API REFERENCE</div>
        <div class="api-ref-body" id="api-ref-body">api.pos(robot)              â†’ {x, y}
api.findCrop(robot, filter) â†’ tile | null
  filter: { ready?, needsWater?, type?, maxDist?, cx?, cy? }
api.findTile(robot, filter) â†’ tile | null
  filter: { tileType?, empty?, maxDist? }
api.moveTo(robot, x, y)     â†’ walk toward tile
api.water(robot, x, y)      â†’ water a crop
api.harvest(robot, x, y)    â†’ harvest ready crop
api.plant(robot, x, y, type)â†’ plant a seed
api.till(robot, x, y)       â†’ hoe grass tile
api.idle(robot)             â†’ stand by
api.mem(robot, key, val?)   â†’ get/set memory
api.inventory(robot)        â†’ {seeds:{...}, crops:{...}}
api.nearby(robot, radius)   â†’ [{x,y,type,crop,...}]
api.distanceTo(robot, x, y) â†’ number (manhattan dist)
robot.assignedCrop          â†’ crop from panel (string)
robot.workArea              â†’ {x, y, radius} | null</div>
        <textarea class="code-area" id="robot-code-editor" placeholder="// Your robot's brain goes here.
// This code runs every few ticks.
// It's the body of: function(robot, api) { ... }

// Example â€” water the nearest thirsty crop:
const t = api.findCrop(robot, { needsWater: true });
if (t) {
  api.moveTo(robot, t.x, t.y);
  api.water(robot, t.x, t.y);
} else {
  api.idle(robot);
}"></textarea>
        <div id="code-error-msg" class="code-error"></div>
        <div style="display:flex;gap:6px;margin-top:6px">
          <button class="game-btn primary" onclick="saveRobotCode()">ğŸ’¾ Save Code</button>
          <button class="game-btn" onclick="clearRobotCode()">ğŸ—‘ Clear</button>
          <button class="game-btn danger" onclick="deleteSelectedRobot()">ğŸ’€ Remove Robot</button>
        </div>
      </div>
    </div>
  </div>
</div>
</div>

<!-- DOCS MODAL -->
<div class="modal-overlay hidden" id="modal-docs">
<div class="modal" style="width:660px;max-height:85vh">
  <div class="modal-header">
    <span class="modal-title">ğŸ“– ROBO FARM GUIDE</span>
    <span class="modal-close" onclick="closeModal('docs')">âœ•</span>
  </div>
  <div class="modal-body docs-body">
    <div class="modal-tabs">
      <button class="tab-btn active" onclick="switchTab('docs','basics')">Basics</button>
      <button class="tab-btn" onclick="switchTab('docs','farming')">Farming</button>
      <button class="tab-btn" onclick="switchTab('docs','robots')">Robots</button>
      <button class="tab-btn" onclick="switchTab('docs','coding')">Robot Coding</button>
      <button class="tab-btn" onclick="switchTab('docs','tips')">Tips</button>
    </div>
    <div id="docs-tab-basics" class="tab-content active">
      <h2>ğŸŒ¾ WELCOME TO ROBO FARM!</h2>
      <p>Hey there, future farming tycoon! You've landed on a beautiful piece of procedurally-generated wilderness. Your mission: turn this wild land into a thriving automated farm empire. Part Stardew Valley coziness, part Factorio efficiency â€” it's farming, but with <strong>robots</strong>.</p>
      <h3>CONTROLS</h3>
      <p><span class="key">W A S D</span> or <span class="key">â†‘ â†“ â† â†’</span> â€” Move your farmer around the world</p>
      <p><span class="key">1-9</span> â€” Select tools from your hotbar</p>
      <p><span class="key">Left Click</span> â€” Use the selected tool on a tile</p>
      <p><span class="key">E</span> â€” Open Shop</p>
      <p><span class="key">R</span> â€” Open Robot Manager</p>
      <p><span class="key">F</span> â€” Open this guide!</p>
      <p><span class="key">Scroll Wheel</span> â€” Zoom in/out</p>
      <p><span class="key">Space</span> â€” Use tool on tile under player</p>
      <p><span class="key">ESC</span> â€” Cancel action / close menus</p>
      <div class="tip">ğŸ’¡ <strong>Pro tip:</strong> You don't have to click exactly on tiles â€” any click near a tile in the game world will use your current tool on the nearest valid target!</div>
      <h3>THE GOAL</h3>
      <p>There's no real "end" â€” just an endlessly satisfying farming loop. <strong>Plant crops, grow them, harvest them, sell them, buy more robots</strong>. Watch your little mechanical farm hands automate everything while you sip virtual coffee and design even better robot programs.</p>
    </div>
    <div id="docs-tab-farming" class="tab-content">
      <h2>ğŸŒ± FARMING GUIDE</h2>
      <h3>THE BASICS</h3>
      <p>Farming happens in three steps: <strong>Till â†’ Plant â†’ Water â†’ Harvest</strong>. Each crop has its own growth timer and water requirements.</p>
      <p><strong>Step 1 â€” Till the Soil:</strong> Select the Hoe tool (<span class="key">2</span>) and click any grass or flower tile in your farm zone. The ground will turn into rich, dark soil ready for planting!</p>
      <p><strong>Step 2 â€” Plant a Seed:</strong> Select any seed from your hotbar (<span class="key">4</span>â€“<span class="key">8</span>) and click a tilled tile. Your farmer will press the seed into the ground. Make sure you actually have seeds â€” buy them at the Shop!</p>
      <p><strong>Step 3 â€” Water It:</strong> Select the Watering Can (<span class="key">3</span>) and click your planted tile. You'll see the soil darken. Each crop needs watering multiple times throughout its growth cycle.</p>
      <p><strong>Step 4 â€” Harvest:</strong> When a crop reaches full size (it'll look bigger and more vibrant!), use the Hand tool (<span class="key">1</span>) and click it. The crops pop into your inventory!</p>
      <div class="tip">ğŸ’¡ <strong>Rain!</strong> On rainy days, ALL crops get watered automatically. Watch for the weather forecast in the top bar â€” plan ahead!</div>
      <h3>CROP GUIDE</h3>
      <p><strong>ğŸŒ¾ Wheat</strong> â€” The starter crop. Fast-growing, low maintenance. Great for beginners and bulk production.</p>
      <p><strong>ğŸ¥• Carrot</strong> â€” Mid-tier. Decent value, moderate water needs. Good middle-ground crop.</p>
      <p><strong>ğŸŒ½ Corn</strong> â€” Slow but profitable! Takes time but yields 4 per harvest. Worth the patience.</p>
      <p><strong>ğŸŒ» Sunflower</strong> â€” Moderate everything. Also looks gorgeous. Sometimes prices spike for these!</p>
      <p><strong>ğŸ¥” Potato</strong> â€” Your bulk crop. Yields 5 per harvest! Great for robots since they water less.</p>
      <p><strong>ğŸ… Tomato</strong> â€” The high roller. Most expensive crop, most demanding. Perfect for dedicated robot teams.</p>
      <h3>SEASONS</h3>
      <p>The year has four seasons: Spring, Summer, Fall, and Winter. <strong>In Winter, crops don't grow</strong> â€” so harvest everything before the snow comes! Robots still work in winter, so you can use that time to prepare your farm.</p>
    </div>
    <div id="docs-tab-robots" class="tab-content">
      <h2>ğŸ¤– ROBOT GUIDE</h2>
      <p>Robots are your best friends. Once you automate your farm, you can focus on expansion, design, and making your robot programs smarter. Buy your first robot at the Shop for 200 coins!</p>
      <h3>PLACING ROBOTS</h3>
      <p>Select the Robot tool (<span class="key">9</span>) and click any walkable tile to place a robot there. The robot will stand by, waiting for instructions. You can have up to 12 robots at once!</p>
      <h3>ASSIGNING TASKS (NO CODING)</h3>
      <p>Select the <strong>Hand tool</strong> (<span class="key">1</span>) and click any robot. The Robot Manager panel will open for that robot. From there:</p>
      <p>1. Choose a <strong>Behavior</strong> from the dropdown (like "Full Cycle" or "Smart Waterer")</p>
      <p>2. Set an <strong>Assigned Crop</strong> (what seeds it should plant)</p>
      <p>3. Click <strong>Set Area</strong> to define the zone it works in â€” then click the center of your field</p>
      <p>4. Done! The robot will get to work immediately.</p>
      <div class="tip">ğŸ’¡ <strong>No coding required!</strong> The built-in behaviors handle everything. "Full Cycle" is the most powerful â€” it harvests, waters, and plants automatically!</div>
      <h3>ROBOT BATTERY</h3>
      <p>Robots have batteries. When they run low, they'll return to their starting position to charge. You can see battery levels in the Robot Manager. Upgrade batteries in a future update for longer work cycles!</p>
      <h3>ROBOT INVENTORY</h3>
      <p>Robots can carry up to 20 items. When they fill up with harvested crops, they'll drop them at your barn (the starting position). The crops automatically go to your inventory!</p>
    </div>
    <div id="docs-tab-coding" class="tab-content">
      <h2>âš¡ ROBOT PROGRAMMING</h2>
      <p>This is where Robo Farm gets <em>really</em> fun. Every robot can run custom JavaScript code as its "brain". You can write behaviors in two places:</p>
      <h3>IN-GAME CODE EDITOR</h3>
      <p>Click a robot â†’ Robot Manager â†’ scroll down to the <strong>Custom JS Code</strong> section. Write your behavior code there. It's like writing the body of a <code>function(robot, api)</code>.</p>
      <h3>IN SETTINGS.JS (RECOMMENDED)</h3>
      <p>Open <code>settings.js</code> in any text editor and find the <code>customBehaviors</code> section. Add your behavior there and it'll show up in the robot's behavior dropdown!</p>
      <h3>THE ROBOT API</h3>
      <p><code>api.pos(robot)</code> â€” Get current tile position <code>&#123;x, y&#125;</code></p>
      <p><code>api.findCrop(robot, filter)</code> â€” Find nearest crop. Filter: <code>&#123; ready, needsWater, type, maxDist, cx, cy &#125;</code></p>
      <p><code>api.findTile(robot, filter)</code> â€” Find nearest tile. Filter: <code>&#123; tileType, empty, maxDist &#125;</code></p>
      <p><code>api.moveTo(robot, x, y)</code> â€” Path toward tile</p>
      <p><code>api.water(robot, x, y)</code> â€” Water a crop tile</p>
      <p><code>api.harvest(robot, x, y)</code> â€” Harvest a ready crop</p>
      <p><code>api.plant(robot, x, y, cropType)</code> â€” Plant a seed</p>
      <p><code>api.till(robot, x, y)</code> â€” Till a grass or flower tile</p>
      <p><code>api.idle(robot)</code> â€” Do nothing this tick</p>
      <p><code>api.mem(robot, key, value?)</code> â€” Get/set persistent memory between ticks</p>
      <p><code>api.inventory(robot)</code> â€” Returns <code>&#123; seeds: &#123;...&#125;, crops: &#123;...&#125; &#125;</code></p>
      <p><code>api.nearby(robot, radius)</code> â€” Array of nearby tile objects</p>
      <div class="tip">ğŸ’¡ <strong>Tip:</strong> Use <code>robot.assignedCrop</code> to get the crop set in the panel, and <code>robot.workArea</code> for <code>&#123;x, y, radius&#125;</code>. Great for making configurable behaviors!</div>
    </div>
    <div id="docs-tab-tips" class="tab-content">
      <h2>âœ¨ TIPS & TRICKS</h2>
      <h3>EARLY GAME</h3>
      <p>Start by tilling a 5x5 plot and planting all your starter wheat. Water it twice and you'll have your first harvest in about a day. Sell those crops and immediately buy your first robot!</p>
      <p>A single "Full Cycle" robot assigned to your wheat field will keep it running while you expand your farm. Use your own time for new development!</p>
      <h3>MID GAME</h3>
      <p>Three robots is the sweet spot for early automation: one waterer, one planter, one harvester. Or use three "Full Cycle" bots for maximum efficiency.</p>
      <p>Don't sleep on <strong>Potatoes</strong> â€” they yield 5 items per harvest and only need watering twice. Excellent robot food!</p>
      <h3>LATE GAME</h3>
      <p>With 8+ robots, you can run multiple dedicated crop zones. Try a dedicated Tomato operation â€” one robot per 3x3 patch, all running Zone Farmer. The income is ridiculous!</p>
      <p>Write custom robot behaviors that adapt to market prices. Check <code>api.mem()</code> examples in the settings.js file!</p>
      <h3>WORLD EXPLORATION</h3>
      <p>Don't stay in your farm zone! The world has forests, rivers, ponds, and wildflower meadows. There's nothing to collect out there (yet!), but it's beautiful. Take a walk sometimes. ğŸŒ²</p>
      <div class="tip">ğŸ’¡ <strong>Secret:</strong> Change the <code>seed</code> value in settings.js to get a completely different world layout. Each seed generates unique river paths, forest positions, and terrain features!</div>
    </div>
  </div>
</div>
</div>

<!-- FILES MODAL -->
<div class="modal-overlay hidden" id="modal-files">
<div class="modal" style="width:520px">
  <div class="modal-header">
    <span class="modal-title">ğŸ“ WORLD FILES</span>
    <span class="modal-close" onclick="closeModal('files')">âœ•</span>
  </div>
  <div class="modal-body" style="display:flex;flex-direction:column;gap:12px">
    <div class="files-card">
      <div class="files-card-title">â¬‡ BACKUP YOUR FARM</div>
      <div class="files-card-desc">Download your entire farm â€” crops, robots, coins, the works â€” as a <code>.js</code> file. Keep it safe. Import it later. Share it with friends. <strong>It's yours.</strong></div>
      <hr class="files-divider">
      <div style="color:var(--text-dim);font-size:13px" id="files-farm-info"></div>
      <button class="big-btn" onclick="exportWorldFile()">ğŸ“¥ Download World File</button>
    </div>
    <div class="files-card">
      <div class="files-card-title">â¬† RESTORE A FARM</div>
      <div class="files-card-desc">Have a world file? Import it here to restore your farm exactly as it was. <strong>This will replace your current farm.</strong></div>
      <hr class="files-divider">
      <button class="big-btn import-btn" onclick="document.getElementById('import-file-input').click()">ğŸ“‚ Import World File</button>
      <div style="color:var(--text-dim);font-size:11px;margin-top:4px;font-family:'Press Start 2P',monospace">Only .js files exported from Robo Farm are accepted.</div>
    </div>
  </div>
</div>
</div>

<!-- CHANGELOG MODAL -->
<div class="modal-overlay hidden" id="modal-changelog">
<div class="modal" style="width:560px;max-height:82vh">
  <div class="modal-header">
    <span class="modal-title">ğŸ“‹ WHAT'S NEW</span>
    <span class="modal-close" onclick="closeModal('changelog')">âœ•</span>
  </div>
  <div class="modal-body changelog-body">
    <div class="changelog-version">ROBO FARM  Â·  v0.2</div>
    <div class="changelog-subtitle">"The Tinkerer's Update" â€” your farm, your files, your code.</div>

    <div class="changelog-section">
      <div class="changelog-section-title">â˜… NEW FEATURES</div>
      <div class="changelog-entry">
        <div class="changelog-star">ğŸ“</div>
        <div class="changelog-text">
          <strong>World Backup Files</strong><br>
          Your farm now has a secret identity â€” a <em>.js file</em> you can download, keep safe, and import back anytime, on any computer. Find it in <strong>[ğŸ“ Files]</strong> in the top bar. It's your farm. Take it with you.
        </div>
      </div>
      <div class="changelog-entry">
        <div class="changelog-star">âš¡</div>
        <div class="changelog-text">
          <strong>Robot Code Editor Upgrades</strong><br>
          The robot programming panel got a full glow-up. <em>Download</em> your bot's code as a .js file, <em>import</em> code from files, pick from <em>templates</em>, and reference the whole API without opening the docs. It runs in a <strong>secure sandbox</strong> â€” your bots can't escape into the browser. They're just farmers.
        </div>
      </div>
    </div>

    <div class="changelog-section">
      <div class="changelog-section-title">âœ¦ SMALL THINGS THAT FEEL GREAT</div>
      <div class="changelog-entry">
        <div class="changelog-star">ğŸ–±</div>
        <div class="changelog-text"><strong>Hold to use tools</strong> â€” Hold the mouse button and drag across tiles to till, water, or plant in a stroke. Tilling a whole row has never felt so satisfying.</div>
      </div>
      <div class="changelog-entry">
        <div class="changelog-star">ğŸŒ±</div>
        <div class="changelog-text"><strong>Crop hover info</strong> â€” Hover any growing crop to see its exact stage, water progress, and whether it's ready. No more guessing.</div>
      </div>
      <div class="changelog-entry">
        <div class="changelog-star">ğŸ†</div>
        <div class="changelog-text"><strong>Milestone moments</strong> â€” Your first harvest, your first robot, big crop counts â€” the game notices the little victories now.</div>
      </div>
      <div class="changelog-entry">
        <div class="changelog-star">ğŸ’¾</div>
        <div class="changelog-text"><strong>Quieter auto-save</strong> â€” Instead of a notification every morning, auto-save now just flashes a tiny <em>âœ“ saved</em> in the corner. Calm. Clean.</div>
      </div>
    </div>

    <div class="changelog-footer">
      Built with â™¥ and way too much virtual coffee.<br>
      Go make something great. We believe in you, farmer. ğŸŒ¾
    </div>
  </div>
</div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ROBO FARM â€” MAIN GAME
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

const S = window.GAME_SETTINGS;
const TILE = S.world.tileSize;
const WW = S.world.width;
const WH = S.world.height;

/* â”€â”€â”€ SEEDED RNG â”€â”€â”€ */
function mkRng(seed) {
  let s = seed >>> 0;
  return () => { s ^= s << 13; s ^= s >> 17; s ^= s << 5; return (s >>> 0) / 4294967296; };
}
const worldRng = mkRng(S.world.seed);

/* â”€â”€â”€ HASH HELPERS â”€â”€â”€ */
function hash2(x, y) { let h = (x * 374761393 + y * 668265263) >>> 0; h = ((h ^ (h >> 13)) * 1274126177) >>> 0; return (h >>> 0) / 4294967296; }
function tileRnd(x, y, i) { return hash2(x * 7 + i, y * 13 + i * 3); }

/* â”€â”€â”€ VALUE NOISE â”€â”€â”€ */
function smoothstep(t) { return t * t * (3 - 2 * t); }
function lerp(a, b, t) { return a + (b - a) * t; }
function valueNoise(x, y, scale) {
  const ix = Math.floor(x / scale), iy = Math.floor(y / scale);
  const fx = (x / scale) - ix, fy = (y / scale) - iy;
  const tx = smoothstep(fx), ty = smoothstep(fy);
  return lerp(lerp(hash2(ix, iy), hash2(ix + 1, iy), tx), lerp(hash2(ix, iy + 1), hash2(ix + 1, iy + 1), tx), ty);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * WORLD GENERATION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let world = [];

function createTile(type) {
  return { type, crop: null, watered: false, variant: 0, animOffset: 0 };
}

function inBounds(x, y) { return x >= 0 && y >= 0 && x < WW && y < WH; }
function isTillableTile(tile) { return tile.type === 'grass' || tile.type === 'flower'; }

function generateWorld() {
  world = [];
  for (let y = 0; y < WH; y++) { world[y] = []; for (let x = 0; x < WW; x++) world[y][x] = createTile('grass'); }

  // Tree noise layer
  for (let y = 0; y < WH; y++) for (let x = 0; x < WW; x++) {
    const n = valueNoise(x, y, 6);
    const edgeDist = Math.min(x, y, WW - 1 - x, WH - 1 - y);
    const edgeBias = edgeDist < 5 ? (5 - edgeDist) / 5 : 0;
    if (n + edgeBias * 0.4 > (1 - S.world.treeFrequency)) {
      world[y][x].type = 'tree'; world[y][x].variant = Math.floor(tileRnd(x, y, 0) * 3);
    }
  }

  // Rocks
  for (let y = 1; y < WH - 1; y++) for (let x = 1; x < WW - 1; x++) {
    if (world[y][x].type === 'grass' && tileRnd(x, y, 1) < S.world.rockFrequency) world[y][x].type = 'rock';
  }

  // Wildflowers
  for (let y = 1; y < WH - 1; y++) for (let x = 1; x < WW - 1; x++) {
    if (world[y][x].type === 'grass' && tileRnd(x, y, 2) < S.world.flowerFrequency) {
      world[y][x].type = 'flower'; world[y][x].variant = Math.floor(tileRnd(x, y, 3) * 5);
    }
  }

  // Rivers
  const riverRng = mkRng(S.world.seed + 100);
  for (let r = 0; r < S.world.riverCount; r++) {
    const startEdge = Math.floor(riverRng() * 4);
    let rx, ry, dirX, dirY;
    if (startEdge === 0) { rx = Math.floor(riverRng() * WW); ry = 0; dirX = 0; dirY = 1; }
    else if (startEdge === 1) { rx = WW - 1; ry = Math.floor(riverRng() * WH); dirX = -1; dirY = 0; }
    else if (startEdge === 2) { rx = Math.floor(riverRng() * WW); ry = WH - 1; dirX = 0; dirY = -1; }
    else { rx = 0; ry = Math.floor(riverRng() * WH); dirX = 1; dirY = 0; }

    for (let step = 0; step < WW + WH; step++) {
      if (!inBounds(rx, ry)) break;
      for (let w = -1; w <= 1; w++) {
        const wx = rx + (dirY !== 0 ? w : 0), wy = ry + (dirX !== 0 ? w : 0);
        if (inBounds(wx, wy)) world[wy][wx].type = 'water';
      }
      const turn = riverRng();
      if (turn < 0.3) { rx += dirX; if (dirX === 0) rx += (riverRng() < 0.5 ? -1 : 1); else ry += (riverRng() < 0.5 ? -1 : 1); }
      else { rx += dirX; ry += dirY; }
      if (riverRng() < 0.15) { const tmp = dirX; dirX = dirY * (riverRng() < 0.5 ? 1 : -1); dirY = tmp * (riverRng() < 0.5 ? 1 : -1); }
    }
  }

  // Ponds
  const pondRng = mkRng(S.world.seed + 200);
  for (let p = 0; p < S.world.pondCount; p++) {
    const px = 5 + Math.floor(pondRng() * (WW - 10));
    const py = 5 + Math.floor(pondRng() * (WH - 10));
    const size = 2 + Math.floor(pondRng() * 4);
    for (let dy = -size; dy <= size; dy++) for (let dx = -size; dx <= size; dx++) {
      if (dx * dx + dy * dy <= size * size * (0.6 + pondRng() * 0.4) && inBounds(px + dx, py + dy))
        world[py + dy][px + dx].type = 'water';
    }
  }

  // Clear farm zone
  const fz = S.world;
  for (let y = fz.farmZoneY; y < fz.farmZoneY + fz.farmZoneH; y++)
    for (let x = fz.farmZoneX; x < fz.farmZoneX + fz.farmZoneW; x++)
      if (inBounds(x, y)) world[y][x] = createTile('grass');

  // Assign anim offsets
  for (let y = 0; y < WH; y++) for (let x = 0; x < WW; x++)
    world[y][x].animOffset = tileRnd(x, y, 9) * Math.PI * 2;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * GAME STATE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let coins = S.player.startCoins;
let day = 1, tick = 0, season = 0;
let isRaining = false, rainDay = false;
const SEASONS = S.time.seasons;
const TPDAY = S.time.ticksPerDay;

let inventory = { seeds: {}, crops: {} };
// Init seeds
for (const [k, v] of Object.entries(S.player.startSeeds)) inventory.seeds[k] = v;

let currentTool = 'hand';
let selectedRobotId = null;
let assigningWorkArea = false;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PLAYER
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const player = {
  tileX: S.player.startX, tileY: S.player.startY,
  px: S.player.startX * TILE, py: S.player.startY * TILE,
  facingX: 0, facingY: 1, moving: false, frame: 0, frameTimer: 0,
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * CAMERA
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const camera = { x: 0, y: 0, tx: 0, ty: 0, zoom: S.display.zoomLevel };

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * INPUT
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const keys = {};
let mouseWorld = { x: 0, y: 0 };
let mouseScreen = { x: 0, y: 0 };

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Digit1') selectTool('hand');
  else if (e.code === 'Digit2') selectTool('hoe');
  else if (e.code === 'Digit3') selectTool('water');
  else if (e.code === 'Digit4') selectTool('wheat');
  else if (e.code === 'Digit5') selectTool('carrot');
  else if (e.code === 'Digit6') selectTool('corn');
  else if (e.code === 'Digit7') selectTool('sunflower');
  else if (e.code === 'Digit8') selectTool('potato');
  else if (e.code === 'Digit9') selectTool('robot_place');
  else if (e.code === 'KeyE') openModal('shop');
  else if (e.code === 'KeyR') openModal('robots');
  else if (e.code === 'KeyF') openModal('docs');
  else if (e.code === 'Escape') { closeAllModals(); cancelAssign(); }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

const canvas = document.getElementById('game');
const cursorCanvas = document.getElementById('cursor-canvas');
const cc = cursorCanvas.getContext('2d');

canvas.addEventListener('mousemove', e => {
  mouseScreen = { x: e.clientX, y: e.clientY };
  const wx = (e.clientX - camera.x) / camera.zoom;
  const wy = (e.clientY - camera.y) / camera.zoom;
  mouseWorld = { x: wx, y: wy };
  updateCursorCanvas();
  updateCropTooltip(e.clientX, e.clientY);
});

canvas.addEventListener('click', e => {
  const tx = Math.floor(mouseWorld.x / TILE);
  const ty = Math.floor(mouseWorld.y / TILE);
  handleTileClick(tx, ty, e);
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  camera.zoom = Math.max(0.5, Math.min(3.0, camera.zoom - e.deltaY * 0.001));
}, { passive: false });

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * BFS PATHFINDING
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function isWalkable(x, y) {
  if (!inBounds(x, y)) return false;
  const t = world[y][x].type;
  return t !== 'tree' && t !== 'water' && t !== 'rock';
}

function findPath(sx, sy, gx, gy) {
  if (sx === gx && sy === gy) return [];
  const queue = [{ x: sx, y: sy }];
  const visited = new Map();
  visited.set(`${sx},${sy}`, null);
  const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
  let safety = 0;
  while (queue.length > 0 && safety++ < 2000) {
    const cur = queue.shift();
    if (cur.x === gx && cur.y === gy) {
      const path = [];
      let k = `${gx},${gy}`;
      while (k !== null) {
        const [px, py] = k.split(',').map(Number);
        path.unshift({ x: px, y: py });
        k = visited.get(k);
      }
      return path.slice(1);
    }
    for (const [dx, dy] of dirs) {
      const nx = cur.x + dx, ny = cur.y + dy;
      const key = `${nx},${ny}`;
      if (!visited.has(key) && (isWalkable(nx, ny) || (nx === gx && ny === gy))) {
        visited.set(key, `${cur.x},${cur.y}`);
        queue.push({ x: nx, y: ny });
      }
    }
  }
  return null;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ROBOTS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let robots = [];
let nextRobotId = 1;

class Robot {
  constructor(tx, ty) {
    this.id = nextRobotId++;
    this.name = `Bot-${this.id}`;
    this.tileX = tx; this.tileY = ty;
    this.px = tx * TILE; this.py = ty * TILE;
    this.homeTileX = tx; this.homeTileY = ty;
    this.battery = S.robots.batteryMax;
    this.path = [];
    this.actionTimer = 0;
    this.workTimer = 0;
    this.state = 'idle';
    this.behavior = S.robots.defaultBehavior;
    this.assignedCrop = 'wheat';
    this.workArea = null;
    this.inventory = { seeds: Object.assign({}, S.player.startSeeds), crops: {} };
    this.inventory.seeds = {};
    this.memory = {};
    this.customCode = '';
    this.compiledCode = null;
    this.codeError = '';
    this.facingX = 0; this.facingY = 1;
    this.frame = 0; this.frameTimer = 0;
  }
}

/* â”€â”€â”€ ROBOT API â”€â”€â”€ */
const robotAPI = {
  pos: (r) => ({ x: r.tileX, y: r.tileY }),

  findCrop: (r, f = {}) => {
    const cx = f.cx ?? r.tileX, cy = f.cy ?? r.tileY, max = f.maxDist ?? 12;
    let best = null, bd = Infinity;
    for (let dy = -max; dy <= max; dy++) for (let dx = -max; dx <= max; dx++) {
      const tx = cx + dx, ty = cy + dy;
      if (!inBounds(tx, ty)) continue;
      const tile = world[ty][tx];
      if (!tile.crop) continue;
      const cfg = S.crops[tile.crop.type];
      if (f.type && tile.crop.type !== f.type) continue;
      if (f.ready && tile.crop.stage < cfg.stages - 1) continue;
      if (f.needsWater) { if (tile.crop.watered || tile.crop.waterCount >= cfg.waterNeeded) continue; }
      const d = Math.abs(dx) + Math.abs(dy);
      if (d < bd) { bd = d; best = { x: tx, y: ty, crop: tile.crop }; }
    }
    return best;
  },

  findTile: (r, f = {}) => {
    const cx = f.cx ?? r.tileX, cy = f.cy ?? r.tileY, max = f.maxDist ?? 12;
    let best = null, bd = Infinity;
    for (let dy = -max; dy <= max; dy++) for (let dx = -max; dx <= max; dx++) {
      const tx = cx + dx, ty = cy + dy;
      if (!inBounds(tx, ty)) continue;
      const tile = world[ty][tx];
      if (f.tileType && tile.type !== f.tileType) continue;
      if (f.empty && tile.crop) continue;
      const d = Math.abs(dx) + Math.abs(dy);
      if (d < bd) { bd = d; best = { x: tx, y: ty, tile }; }
    }
    return best;
  },

  moveTo: (r, x, y) => {
    if (r.tileX === x && r.tileY === y) return;
    if (!r._targetX || r._targetX !== x || r._targetY !== y) {
      r._targetX = x; r._targetY = y;
      r.path = findPath(r.tileX, r.tileY, x, y) || [];
    }
  },

  water: (r, x, y) => {
    if (Math.abs(r.tileX - x) > 1 || Math.abs(r.tileY - y) > 1) { robotAPI.moveTo(r, x, y); return false; }
    if (!inBounds(x, y) || !world[y][x].crop) return false;
    const crop = world[y][x].crop;
    if (crop.watered || crop.waterCount >= S.crops[crop.type].waterNeeded) return false;
    r.state = 'working'; r.actionTimer = 20;
    r._pendingAction = { type: 'water', x, y };
    return true;
  },

  harvest: (r, x, y) => {
    if (Math.abs(r.tileX - x) > 1 || Math.abs(r.tileY - y) > 1) { robotAPI.moveTo(r, x, y); return false; }
    if (!inBounds(x, y) || !world[y][x].crop) return false;
    const crop = world[y][x].crop;
    if (crop.stage < S.crops[crop.type].stages - 1) return false;
    r.state = 'working'; r.actionTimer = 20;
    r._pendingAction = { type: 'harvest', x, y };
    return true;
  },

  plant: (r, x, y, type) => {
    if (Math.abs(r.tileX - x) > 1 || Math.abs(r.tileY - y) > 1) { robotAPI.moveTo(r, x, y); return false; }
    if (!inBounds(x, y) || world[y][x].type !== 'tilled' || world[y][x].crop) return false;
    if (!r.inventory.seeds[type] || r.inventory.seeds[type] <= 0) {
      // Pull seeds from player if possible
      if (inventory.seeds[type] > 0) {
        const take = Math.min(10, inventory.seeds[type]);
        inventory.seeds[type] -= take;
        r.inventory.seeds[type] = (r.inventory.seeds[type] || 0) + take;
        updateUI();
      } else return false;
    }
    r.state = 'working'; r.actionTimer = 20;
    r._pendingAction = { type: 'plant', x, y, cropType: type };
    return true;
  },

  till: (r, x, y) => {
    if (Math.abs(r.tileX - x) > 1 || Math.abs(r.tileY - y) > 1) { robotAPI.moveTo(r, x, y); return false; }
    if (!inBounds(x, y) || !isTillableTile(world[y][x])) return false;
    r.state = 'working'; r.actionTimer = 25;
    r._pendingAction = { type: 'till', x, y };
    return true;
  },

  idle: (r) => { r.state = 'idle'; r.path = []; r._pendingAction = null; },

  mem: (r, k, v) => { if (v !== undefined) r.memory[k] = v; return r.memory[k]; },

  inventory: (r) => r.inventory,

  nearby: (r, radius) => {
    const res = [];
    for (let dy = -radius; dy <= radius; dy++) for (let dx = -radius; dx <= radius; dx++) {
      const tx = r.tileX + dx, ty = r.tileY + dy;
      if (inBounds(tx, ty)) res.push({ x: tx, y: ty, ...world[ty][tx] });
    }
    return res;
  },

  distanceTo: (r, x, y) => Math.abs(r.tileX - x) + Math.abs(r.tileY - y),
};

/* â”€â”€â”€ BUILT-IN BEHAVIORS â”€â”€â”€ */
const builtinBehaviors = {
  'idle': (r, api) => api.idle(r),

  'water_area': (r, api) => {
    const t = api.findCrop(r, { needsWater: true, maxDist: r.workArea?.radius || 10, cx: r.workArea?.x, cy: r.workArea?.y });
    if (t) { api.moveTo(r, t.x, t.y); api.water(r, t.x, t.y); } else api.idle(r);
  },

  'harvest': (r, api) => {
    const t = api.findCrop(r, { ready: true, maxDist: r.workArea?.radius || 10, cx: r.workArea?.x, cy: r.workArea?.y });
    if (t) { api.moveTo(r, t.x, t.y); api.harvest(r, t.x, t.y); } else api.idle(r);
  },

  'full_cycle': (r, api) => {
    const max = r.workArea?.radius || 12, cx = r.workArea?.x, cy = r.workArea?.y;
    const ready = api.findCrop(r, { ready: true, maxDist: max, cx, cy });
    if (ready) { api.moveTo(r, ready.x, ready.y); api.harvest(r, ready.x, ready.y); return; }
    const thirsty = api.findCrop(r, { needsWater: true, maxDist: max, cx, cy });
    if (thirsty) { api.moveTo(r, thirsty.x, thirsty.y); api.water(r, thirsty.x, thirsty.y); return; }
    const crop = r.assignedCrop || 'wheat';
    if ((r.inventory.seeds[crop] || 0) > 0 || (inventory.seeds[crop] || 0) > 0) {
      const empty = api.findTile(r, { tileType: 'tilled', empty: true, maxDist: max, cx, cy });
      if (empty) { api.moveTo(r, empty.x, empty.y); api.plant(r, empty.x, empty.y, crop); return; }
    }
    api.idle(r);
  },
};

/* â”€â”€â”€ ALL BEHAVIORS (builtin + custom from settings.js) â”€â”€â”€ */
function getAllBehaviors() {
  return { ...builtinBehaviors, ...(S.customBehaviors || {}) };
}

function runRobotBehavior(robot) {
  robot.workTimer++;
  if (robot.workTimer < S.robots.workDelay) return;
  robot.workTimer = 0;

  if (robot.battery <= 0) {
    robotAPI.moveTo(robot, robot.homeTileX, robot.homeTileY);
    return;
  }

  if (robot.compiledCode) {
    try { runSandboxed(robot, robot.compiledCode); robot.codeError = ''; }
    catch (e) { robot.codeError = e.message; robotAPI.idle(robot); }
    return;
  }

  const behaviors = getAllBehaviors();
  const fn = behaviors[robot.behavior] || behaviors['idle'];
  try { fn(robot, robotAPI); } catch(e) { robotAPI.idle(robot); }
}

function updateRobots() {
  for (const robot of robots) {
    // Handle pending action completion
    if (robot.actionTimer > 0) {
      robot.actionTimer--;
      if (robot.actionTimer === 0 && robot._pendingAction) {
        const a = robot._pendingAction;
        robot._pendingAction = null;
        executeRobotAction(robot, a);
      }
      continue;
    }

    // Battery
    if (robot.state === 'working') robot.battery = Math.max(0, robot.battery - S.robots.batteryDrain);
    if (robot.tileX === robot.homeTileX && robot.tileY === robot.homeTileY && robot.battery < S.robots.batteryMax) {
      robot.battery = Math.min(S.robots.batteryMax, robot.battery + S.robots.chargeRate / 60);
    }

    // Drop crops at home
    if (robot.tileX === robot.homeTileX && robot.tileY === robot.homeTileY) {
      for (const [type, qty] of Object.entries(robot.inventory.crops)) {
        if (qty > 0) {
          inventory.crops[type] = (inventory.crops[type] || 0) + qty;
          robot.inventory.crops[type] = 0;
          notify(`ğŸ¤– ${robot.name} delivered ${qty}x ${S.crops[type].emoji} ${type}!`);
          updateUI();
        }
      }
    }

    // Follow path
    if (robot.path && robot.path.length > 0) {
      const next = robot.path[0];
      const speed = S.robots.speed * TILE / 60;
      const dx = next.x * TILE - robot.px, dy = next.y * TILE - robot.py;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < speed + 1) {
        robot.px = next.x * TILE; robot.py = next.y * TILE;
        robot.tileX = next.x; robot.tileY = next.y;
        robot.path.shift();
        robot.battery = Math.max(0, robot.battery - S.robots.batteryDrain * 0.3);
      } else {
        robot.px += (dx / dist) * speed;
        robot.py += (dy / dist) * speed;
        robot.facingX = Math.sign(dx); robot.facingY = Math.sign(dy);
      }
      robot.frameTimer++;
      if (robot.frameTimer > 10) { robot.frame = (robot.frame + 1) % 4; robot.frameTimer = 0; }
      robot.state = 'moving';
    } else {
      robot.state = robot.battery <= 10 ? 'charging' : 'idle';
      runRobotBehavior(robot);
    }
  }
}

function executeRobotAction(robot, action) {
  if (!inBounds(action.x, action.y)) return;
  const tile = world[action.y][action.x];

  if (action.type === 'water' && tile.crop) {
    const cfg = S.crops[tile.crop.type];
    if (!tile.crop.watered && tile.crop.waterCount < cfg.waterNeeded) {
      tile.crop.watered = true;
      spawnParticles(action.x * TILE + TILE/2, action.y * TILE, 'water', 6);
    }
  } else if (action.type === 'harvest' && tile.crop) {
    const cfg = S.crops[tile.crop.type];
    if (tile.crop.stage >= cfg.stages - 1) {
      const total = cfg.yield;
      robot.inventory.crops[tile.crop.type] = (robot.inventory.crops[tile.crop.type] || 0) + total;
      spawnParticles(action.x * TILE + TILE/2, action.y * TILE, 'harvest', 10);
      tile.crop = null;
    }
  } else if (action.type === 'plant') {
    if (tile.type === 'tilled' && !tile.crop) {
      const seeds = robot.inventory.seeds;
      const type = action.cropType;
      if ((seeds[type] || 0) > 0) {
        seeds[type]--;
        tile.crop = { type, stage: 0, growTimer: 0, waterCount: 0, watered: false };
      }
    }
  } else if (action.type === 'till' && isTillableTile(tile)) {
    tile.type = 'tilled';
    spawnParticles(action.x * TILE + TILE/2, action.y * TILE, 'dirt', 5);
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * CROP SYSTEM
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let cropTick = 0;

function updateCrops() {
  cropTick++;
  if (cropTick % 30 !== 0) return;

  const season_name = SEASONS[season % SEASONS.length];
  if (season_name === 'Winter' && S.time.winterEnabled) return;

  for (let y = 0; y < WH; y++) for (let x = 0; x < WW; x++) {
    const tile = world[y][x];
    if (!tile.crop) continue;
    const crop = tile.crop;
    const cfg = S.crops[crop.type];
    if (!cfg) continue;

    if (crop.watered || rainDay) {
      crop.growTimer += 30;
      if (crop.watered) { crop.waterCount++; crop.watered = false; }
    }

    const stageTime = cfg.growTime / cfg.stages;
    const newStage = Math.min(cfg.stages - 1, Math.floor(crop.growTimer / stageTime));
    if (newStage > crop.stage) {
      crop.stage = newStage;
      if (crop.stage >= cfg.stages - 1) spawnParticles(x * TILE + TILE/2, y * TILE, 'grow', 8);
    }
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PARTICLES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let particles = [];
const MAX_PARTICLES = S.display.particleCount === 'low' ? 50 : S.display.particleCount === 'medium' ? 150 : 300;

function spawnParticles(px, py, type, count) {
  if (particles.length > MAX_PARTICLES) return;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 2.5;
    let color = '#ffffff';
    if (type === 'water') color = ['#4fc3f7','#29b6f6','#81d4fa'][i%3];
    else if (type === 'harvest') color = ['#f5c842','#a5d86e','#ff9944'][i%3];
    else if (type === 'dirt') color = ['#7d5a2a','#5c3d18','#9b7a45'][i%3];
    else if (type === 'grow') color = ['#66bb6a','#a5d86e','#fff176'][i%3];
    particles.push({ x: px, y: py, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - 1, life: 1, color, size: 2 + Math.random() * 3 });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.08; p.life -= 0.03;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * TILE CLICK HANDLER
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function handleTileClick(tx, ty, e) {
  if (!inBounds(tx, ty)) return;

  // Work area assignment
  if (assigningWorkArea && selectedRobotId !== null) {
    const bot = robots.find(r => r.id === selectedRobotId);
    if (bot) {
      bot.workArea = { x: tx, y: ty, radius: 8 };
      document.getElementById('robot-area-display').textContent = `(${tx}, ${ty}) r=8`;
      notify(`ğŸ¤– ${bot.name} work area set to (${tx}, ${ty})`);
    }
    cancelAssign(); return;
  }

  const tile = world[ty][tx];

  if (currentTool === 'hand') {
    // Check if clicking a robot
    const bot = robots.find(r => r.tileX === tx && r.tileY === ty);
    if (bot) { selectedRobotId = bot.id; openModal('robots'); return; }
    // Harvest ready crop
    if (tile.crop) {
      const cfg = S.crops[tile.crop.type];
      if (tile.crop.stage >= cfg.stages - 1) {
        const got = cfg.yield;
        inventory.crops[tile.crop.type] = (inventory.crops[tile.crop.type] || 0) + got;
        spawnParticles(tx * TILE + TILE/2, ty * TILE, 'harvest', 12);
        notify(`${cfg.emoji} Harvested ${got}x ${tile.crop.type}!`);
        tile.crop = null; updateUI(); checkMilestones();
      } else notify(`ğŸ• Crop not ready yet (${tile.crop.stage + 1}/${cfg.stages})`);
    }
  } else if (currentTool === 'hoe') {
    if (isTillableTile(tile)) {
      tile.type = 'tilled';
      spawnParticles(tx * TILE + TILE/2, ty * TILE, 'dirt', 6);
    } else if (tile.type === 'tilled' && !tile.crop) {
      tile.type = 'grass';
    }
  } else if (currentTool === 'water') {
    if (tile.type === 'tilled' && tile.crop && !tile.crop.watered) {
      const cfg = S.crops[tile.crop.type];
      if (tile.crop.waterCount < cfg.waterNeeded) {
        tile.crop.watered = true;
        spawnParticles(tx * TILE + TILE/2, ty * TILE, 'water', 8);
        notify(`ğŸ’§ Watered ${tile.crop.type} (${tile.crop.waterCount + 1}/${cfg.waterNeeded})`);
      } else notify(`âœ… Crop is fully watered!`);
    } else notify(`ğŸ’§ Nothing to water here!`);
  } else if (currentTool === 'robot_place') {
    if (isWalkable(tx, ty)) {
      if (robots.length >= S.robots.maxRobots) { notify(`âš ï¸ Max robots reached (${S.robots.maxRobots})`); return; }
      // Use robot from player 'inventory'
      if (!playerHasRobot()) { notify(`ğŸ¤– Buy a robot at the Shop first!`); return; }
      usePlayerRobot();
      const bot = new Robot(tx, ty);
      robots.push(bot);
      notify(`ğŸ¤– ${bot.name} deployed!`);
      updateUI(); checkMilestones();
    }
  } else {
    // Seed tools
    const cropType = currentTool;
    if (S.crops[cropType]) {
      if (!inventory.seeds[cropType] || inventory.seeds[cropType] <= 0) {
        notify(`âŒ No ${cropType} seeds! Buy some at the Shop.`); return;
      }
      if (tile.type === 'tilled' && !tile.crop) {
        inventory.seeds[cropType]--;
        tile.crop = { type: cropType, stage: 0, growTimer: 0, waterCount: 0, watered: false };
        spawnParticles(tx * TILE + TILE/2, ty * TILE, 'dirt', 4);
        updateUI();
      } else if (tile.type !== 'tilled') notify(`â›ï¸ Till the soil first!`);
    }
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PLAYER ROBOT INVENTORY
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let robotsOwned = S.player.startRobots;
function playerHasRobot() { return robotsOwned > 0; }
function usePlayerRobot() { robotsOwned = Math.max(0, robotsOwned - 1); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ECONOMY
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let priceMultipliers = {};
function refreshPrices() {
  if (!S.economy.priceFluctuation) { for (const k of Object.keys(S.crops)) priceMultipliers[k] = 1; return; }
  for (const k of Object.keys(S.crops)) priceMultipliers[k] = 1 + (Math.random() - 0.5) * 2 * S.economy.fluctuationAmount;
}
refreshPrices();

function getCropPrice(type) { return Math.round((S.economy.cropPrices[type] || 10) * (priceMultipliers[type] || 1)); }

function buySeeds(type, qty) {
  const cost = (S.economy.seedPrices[type] || 5) * qty;
  if (coins < cost) { notify(`âŒ Need ${cost} coins!`); return; }
  coins -= cost; inventory.seeds[type] = (inventory.seeds[type] || 0) + qty;
  notify(`âœ… Bought ${qty}x ${S.crops[type]?.emoji} ${type} seeds!`);
  updateUI(); buildShop();
}

function buyRobot() {
  const cost = S.economy.robotCost;
  if (coins < cost) { notify(`âŒ Need ${cost} coins! Sell some crops.`); return; }
  coins -= cost; robotsOwned++;
  notify(`ğŸ¤– Robot purchased! Use the Robot tool (9) to place it.`);
  updateUI();
  document.getElementById('robot-count-display').textContent = `Owned: ${robotsOwned}`;
}

function sellCrop(type) {
  const qty = inventory.crops[type] || 0;
  if (qty <= 0) { notify(`âŒ No ${type} to sell!`); return; }
  const bonus = qty >= 10 ? S.economy.bulkBonus : 1;
  const earned = Math.round(getCropPrice(type) * qty * bonus);
  coins += earned; delete inventory.crops[type];
  notify(`ğŸ’° Sold ${qty}x ${type} for ${earned} coins${bonus > 1 ? ' (bulk bonus!)' : ''}!`);
  updateUI(); buildSellGrid();
}

function sellAll() {
  let total = 0;
  for (const [type, qty] of Object.entries(inventory.crops)) {
    if (qty > 0) {
      const bonus = qty >= 10 ? S.economy.bulkBonus : 1;
      total += Math.round(getCropPrice(type) * qty * bonus);
    }
  }
  if (total === 0) { notify(`âŒ Nothing to sell!`); return; }
  coins += total; inventory.crops = {};
  notify(`ğŸ’° Sold everything for ${total} coins!`);
  updateUI(); buildSellGrid();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * SAVE / LOAD
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function saveGame() {
  const save = buildSaveObject();
  try {
    localStorage.setItem('roboFarm_save', JSON.stringify(save));
    const flash = document.getElementById('save-flash');
    if (flash) { flash.style.opacity = '1'; setTimeout(() => flash.style.opacity = '0', 1200); }
  } catch(e) { notify('âŒ Save failed!'); }
}

function loadGame() {
  try {
    const raw = localStorage.getItem('roboFarm_save');
    if (!raw) return false;
    const save = JSON.parse(raw);
    if (save.v !== 2) { localStorage.removeItem('roboFarm_save'); return false; }
    applyGameSave(save);
    return true;
  } catch(e) { console.warn('Load failed', e); return false; }
}

/* compileRobotCode is defined above in the SECURE ROBOT CODE SANDBOX section */
function _compileRobotCode_placeholder() {}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * RENDERING
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const gameCanvas = document.getElementById('game');
const ctx = gameCanvas.getContext('2d');
let W = 0, H = 0;

const GRASS_COLORS = ['#3d7f38','#4a8c44','#44864e','#529448'];
const WATER_COLORS = ['#1a6fa3','#2478b0','#1c7abd'];
const FLOWER_COLORS = ['#ff6b9d','#ff9f43','#ffd32a','#a29bfe','#ff7675'];
const TREE_TRUNK = '#5c3d1a';
const TREE_CANOPY = ['#2d6e25','#356b2a','#3d7a32','#2a6020'];

function resize() {
  W = window.innerWidth; H = window.innerHeight;
  gameCanvas.width = W; gameCanvas.height = H;
  cursorCanvas.width = W; cursorCanvas.height = H;
}

let animTime = 0;

function render() {
  ctx.save();
  ctx.clearRect(0, 0, W, H);

  // Sky
  const dayProgress = tick / TPDAY;
  const skyColor = getSkyColor(dayProgress);
  ctx.fillStyle = skyColor;
  ctx.fillRect(0, 0, W, H);

  // Camera transform
  ctx.setTransform(camera.zoom, 0, 0, camera.zoom, camera.x, camera.y);

  // Viewport culling
  const vx0 = Math.max(0, Math.floor(-camera.x / (TILE * camera.zoom)) - 1);
  const vy0 = Math.max(0, Math.floor(-camera.y / (TILE * camera.zoom)) - 1);
  const vx1 = Math.min(WW - 1, Math.ceil((W - camera.x) / (TILE * camera.zoom)) + 1);
  const vy1 = Math.min(WH - 1, Math.ceil((H - camera.y) / (TILE * camera.zoom)) + 1);

  // Draw tiles
  for (let y = vy0; y <= vy1; y++) {
    for (let x = vx0; x <= vx1; x++) {
      drawTile(x, y);
    }
  }

  // Draw crops
  for (let y = vy0; y <= vy1; y++) {
    for (let x = vx0; x <= vx1; x++) {
      if (world[y][x].crop) drawCrop(x, y);
    }
  }

  // Draw robots
  for (const bot of robots) drawRobot(bot);

  // Draw player
  drawPlayer();

  // Draw particles
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  // Draw robot work areas
  if (S.display.showRobotPath) {
    for (const bot of robots) {
      if (bot.workArea && selectedRobotId === bot.id) {
        ctx.strokeStyle = 'rgba(255,200,50,0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc((bot.workArea.x + 0.5) * TILE, (bot.workArea.y + 0.5) * TILE, bot.workArea.radius * TILE, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      if (bot.path && bot.path.length > 0 && selectedRobotId === bot.id) {
        ctx.strokeStyle = 'rgba(100,200,255,0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(bot.px + TILE/2, bot.py + TILE/2);
        for (const step of bot.path) ctx.lineTo(step.x * TILE + TILE/2, step.y * TILE + TILE/2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }

  // Highlight hovered tile
  const htx = Math.floor(mouseWorld.x / TILE);
  const hty = Math.floor(mouseWorld.y / TILE);
  if (inBounds(htx, hty)) {
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1.5 / camera.zoom;
    ctx.strokeRect(htx * TILE + 0.5, hty * TILE + 0.5, TILE - 1, TILE - 1);
  }

  // Night overlay
  const nightAlpha = getNightAlpha(dayProgress);
  if (nightAlpha > 0) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = `rgba(10, 5, 30, ${nightAlpha})`;
    ctx.fillRect(0, 0, W, H);
    // Stars at night
    if (nightAlpha > 0.3) drawStars(nightAlpha);
  }

  // Rain overlay
  if (rainDay) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    drawRain();
  }

  ctx.restore();
}

function getSkyColor(dp) {
  if (dp < 0.2) return lerpColor('#0d1b3e', '#ff8c42', dp / 0.2);
  if (dp < 0.4) return lerpColor('#ff8c42', '#87ceeb', (dp - 0.2) / 0.2);
  if (dp < 0.7) return '#87ceeb';
  if (dp < 0.85) return lerpColor('#87ceeb', '#ff6b35', (dp - 0.7) / 0.15);
  return lerpColor('#ff6b35', '#0d1b3e', (dp - 0.85) / 0.15);
}

function getNightAlpha(dp) {
  if (dp < 0.1) return lerp(0.7, 0, dp / 0.1);
  if (dp > 0.9) return lerp(0, 0.7, (dp - 0.9) / 0.1);
  return 0;
}

function lerpColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
  const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
  return `rgb(${Math.round(r1+(r2-r1)*t)},${Math.round(g1+(g2-g1)*t)},${Math.round(b1+(b2-b1)*t)})`;
}

function drawStars(alpha) {
  ctx.fillStyle = `rgba(255,255,255,${alpha * 0.6})`;
  for (let i = 0; i < 80; i++) {
    const sx = hash2(i * 7, 1) * W;
    const sy = hash2(i * 3, 2) * H * 0.5;
    const blink = Math.sin(animTime * 0.05 + i) * 0.3 + 0.7;
    ctx.globalAlpha = alpha * blink * 0.7;
    ctx.fillRect(sx, sy, 1.5, 1.5);
  }
  ctx.globalAlpha = 1;
}

function drawRain() {
  ctx.strokeStyle = 'rgba(160,200,255,0.25)';
  ctx.lineWidth = 1;
  const count = 120;
  for (let i = 0; i < count; i++) {
    const rx = ((hash2(i, 1) * W + animTime * 3) % W);
    const ry = ((hash2(i, 2) * H + animTime * 8) % H);
    ctx.beginPath(); ctx.moveTo(rx, ry); ctx.lineTo(rx - 2, ry + 10); ctx.stroke();
  }
}

function drawTile(x, y) {
  const tile = world[y][x];
  const px = x * TILE, py = y * TILE;
  const rnd = tileRnd(x, y, 0);

  if (tile.type === 'grass' || tile.type === 'flower') {
    ctx.fillStyle = GRASS_COLORS[Math.floor(rnd * 4)];
    ctx.fillRect(px, py, TILE, TILE);
    // Grass blades
    ctx.fillStyle = rnd > 0.5 ? '#3a7035' : '#4fa040';
    for (let i = 0; i < 3; i++) {
      const bx = px + tileRnd(x, y, i+1) * TILE, by = py + tileRnd(x, y, i+4) * TILE;
      ctx.fillRect(bx, by, 1, 3);
    }
    if (tile.type === 'flower') {
      const fc = FLOWER_COLORS[tile.variant];
      const fx = px + 4 + rnd * (TILE - 12), fy = py + 5 + tileRnd(x,y,8) * (TILE - 14);
      ctx.fillStyle = '#5a8a3a'; ctx.fillRect(fx + 1, fy - 2, 1, 6);
      ctx.fillStyle = fc; ctx.fillRect(fx, fy - 4, 4, 3);
      ctx.fillRect(fx - 1, fy - 3, 6, 1);
    }
  } else if (tile.type === 'tilled') {
    ctx.fillStyle = '#3c240e'; ctx.fillRect(px, py, TILE, TILE);
    ctx.fillStyle = '#4f3018';
    for (let i = 0; i < TILE; i += 4) { ctx.fillRect(px, py + i, TILE, 2); }
    if (tile.watered || (tile.crop && tile.crop.watered)) {
      ctx.fillStyle = 'rgba(30, 80, 150, 0.25)'; ctx.fillRect(px, py, TILE, TILE);
    }
  } else if (tile.type === 'water') {
    const wv = Math.sin(animTime * 0.05 + tile.animOffset) * 0.15 + 0.85;
    const wi = Math.floor(wv * WATER_COLORS.length) % WATER_COLORS.length;
    ctx.fillStyle = WATER_COLORS[wi]; ctx.fillRect(px, py, TILE, TILE);
    // Shimmer
    ctx.fillStyle = `rgba(255,255,255,${0.1 + Math.sin(animTime * 0.08 + rnd * 6) * 0.06})`;
    ctx.fillRect(px + 4, py + 8, TILE - 10, 2);
    ctx.fillRect(px + 10, py + 18, TILE - 16, 2);
  } else if (tile.type === 'tree') {
    ctx.fillStyle = GRASS_COLORS[0]; ctx.fillRect(px, py, TILE, TILE);
    ctx.fillStyle = TREE_TRUNK; ctx.fillRect(px + TILE/2 - 3, py + TILE/2 + 2, 6, TILE/2);
    ctx.fillStyle = TREE_CANOPY[tile.variant % 4];
    ctx.beginPath(); ctx.arc(px + TILE/2, py + TILE/2, TILE/2 - 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.arc(px + TILE/2 + 2, py + TILE/2 + 2, TILE/2 - 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = TREE_CANOPY[tile.variant % 4];
    ctx.beginPath(); ctx.arc(px + TILE/2, py + TILE/2, TILE/2 - 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.arc(px + TILE/2 - 3, py + TILE/2 - 4, 4, 0, Math.PI * 2); ctx.fill();
  } else if (tile.type === 'rock') {
    ctx.fillStyle = GRASS_COLORS[0]; ctx.fillRect(px, py, TILE, TILE);
    ctx.fillStyle = '#888'; ctx.fillRect(px + 5, py + 8, TILE - 10, TILE - 14);
    ctx.fillStyle = '#aaa'; ctx.fillRect(px + 6, py + 9, 4, 3);
    ctx.fillStyle = '#666'; ctx.fillRect(px + 5, py + 18, TILE - 10, 4);
  }
}

function drawCrop(x, y) {
  const tile = world[y][x];
  const crop = tile.crop;
  const cfg = S.crops[crop.type];
  const px = x * TILE, py = y * TILE;
  const progress = crop.stage / (cfg.stages - 1);
  const h = Math.round(4 + progress * (TILE - 8));
  const w = Math.round(3 + progress * (TILE - 16));
  const cx = px + TILE / 2;
  const bot = py + TILE - 4;
  const wobble = Math.sin(animTime * 0.08 + tile.animOffset) * (2 * progress);

  ctx.fillStyle = '#5a8a3a';
  ctx.fillRect(cx - 1, bot - h, 2, h);

  if (crop.stage >= 1) {
    ctx.fillStyle = cfg.color;
    ctx.fillRect(cx - w/2 + wobble, bot - h, w, Math.round(h * 0.6));
    if (crop.stage >= 2) {
      ctx.fillStyle = '#6aad48';
      ctx.fillRect(cx - 4 + wobble * 0.7, bot - h * 0.5, 8, 4);
    }
    if (crop.stage >= cfg.stages - 1) {
      // Ready bounce + glow
      const bounce = Math.sin(animTime * 0.12 + tile.animOffset * 3) * 2;
      ctx.fillStyle = 'rgba(255,230,50,0.25)';
      ctx.beginPath(); ctx.arc(cx, bot - h / 2 + bounce, w/2 + 3, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = cfg.color;
      ctx.fillRect(cx - w/2 + wobble, bot - h + bounce, w, Math.round(h * 0.6));
    }
  }

  // Watered indicator
  if (tile.crop.watered) {
    ctx.fillStyle = 'rgba(70,180,255,0.4)';
    ctx.fillRect(px + 1, py + TILE - 4, TILE - 2, 3);
  }
}

function drawPlayer() {
  const px = player.px + 2, py = player.py;
  const leg = (player.frame % 2 === 0 && player.moving) ? 2 : 0;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(px + 2, py + TILE - 6, TILE - 10, 4);

  // Legs
  ctx.fillStyle = '#4a3a8c';
  ctx.fillRect(px + 4, py + TILE - 12, 4, 8 - leg);
  ctx.fillRect(px + TILE - 14, py + TILE - 12, 4, 8 + leg);

  // Body (overalls)
  ctx.fillStyle = '#6a9ae8';
  ctx.fillRect(px + 2, py + TILE - 20, TILE - 10, 10);

  // Arms
  ctx.fillStyle = '#c07848';
  ctx.fillRect(px - 2, py + TILE - 20, 4, 8);
  ctx.fillRect(px + TILE - 8, py + TILE - 20, 4, 8);

  // Head
  ctx.fillStyle = '#d49060';
  ctx.fillRect(px + 4, py + TILE - 28, TILE - 14, 10);

  // Hat
  ctx.fillStyle = '#8b5e2a';
  ctx.fillRect(px + 2, py + TILE - 28, TILE - 10, 3);
  ctx.fillRect(px + 5, py + TILE - 32, TILE - 16, 6);

  // Eyes
  ctx.fillStyle = '#222';
  ctx.fillRect(px + 7, py + TILE - 25, 2, 2);
  ctx.fillRect(px + 13, py + TILE - 25, 2, 2);
}

function drawRobot(bot) {
  const px = bot.px + 2, py = bot.py;
  const selected = bot.id === selectedRobotId;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(px + 2, py + TILE - 4, TILE - 10, 4);

  // Wheels/tracks
  ctx.fillStyle = '#333';
  ctx.fillRect(px + 1, py + TILE - 10, TILE - 8, 5);

  // Body
  ctx.fillStyle = selected ? '#c8d8f0' : '#a8b8c8';
  ctx.fillRect(px + 3, py + TILE - 22, TILE - 12, 14);

  // Panel details
  ctx.fillStyle = '#7a8a98';
  ctx.fillRect(px + 5, py + TILE - 20, 6, 4);
  ctx.fillRect(px + TILE - 18, py + TILE - 20, 6, 4);

  // Head
  ctx.fillStyle = selected ? '#d8e8ff' : '#b8c8d8';
  ctx.fillRect(px + 5, py + TILE - 30, TILE - 16, 10);

  // Eyes (LED)
  const eyeColor = bot.battery > 30 ? (bot.state === 'working' ? '#40ff80' : '#ffcc00') : '#ff4040';
  ctx.fillStyle = eyeColor;
  ctx.fillRect(px + 7, py + TILE - 28, 3, 3);
  ctx.fillRect(px + TILE - 18, py + TILE - 28, 3, 3);
  // Eye glow
  ctx.fillStyle = eyeColor.replace(')', ',0.3)').replace('rgb','rgba');
  ctx.fillRect(px + 6, py + TILE - 29, 5, 5);
  ctx.fillRect(px + TILE - 19, py + TILE - 29, 5, 5);

  // Antenna
  ctx.fillStyle = '#888';
  ctx.fillRect(px + TILE/2 - 5, py + TILE - 34, 2, 6);
  ctx.fillStyle = selected ? '#ffcc00' : '#cc4444';
  ctx.fillRect(px + TILE/2 - 6, py + TILE - 37, 4, 4);

  // Battery bar above robot
  const barW = TILE - 8;
  const bPct = bot.battery / S.robots.batteryMax;
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(px + 1, py - 8, barW, 5);
  ctx.fillStyle = bPct > 0.5 ? '#40cc40' : bPct > 0.2 ? '#ffaa00' : '#ff4040';
  ctx.fillRect(px + 1, py - 8, barW * bPct, 5);

  // Selection highlight
  if (selected) {
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([3, 3]);
    ctx.strokeRect(px, py + TILE - 32, TILE - 6, 32);
    ctx.setLineDash([]);
  }

  // Error indicator
  if (bot.codeError) {
    ctx.fillStyle = '#ff4040';
    ctx.fillRect(px + TILE - 14, py + TILE - 38, 8, 8);
    ctx.fillStyle = 'white';
    ctx.font = '6px sans-serif';
    ctx.fillText('!', px + TILE - 12, py + TILE - 32);
  }
}

function updateCursorCanvas() {
  cc.clearRect(0, 0, W, H);
  if (document.body.classList.contains('show-system-cursor')) return;
  const mx = mouseScreen.x, my = mouseScreen.y;
  const toolCursors = { hand:'âœ‹', hoe:'â›ï¸', water:'ğŸ’§', robot_place:'ğŸ¤–' };
  const seedCursors = { wheat:'ğŸŒ¾', carrot:'ğŸ¥•', corn:'ğŸŒ½', sunflower:'ğŸŒ»', potato:'ğŸ¥”', tomato:'ğŸ…' };
  const icon = toolCursors[currentTool] || seedCursors[currentTool] || 'âœ‹';
  cc.font = '20px serif';
  cc.fillText(icon, mx - 10, my + 8);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * GAME LOOP
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function update() {
  // Player movement
  let dx = 0, dy = 0;
  if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
  if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
  if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
  if (keys['KeyD'] || keys['ArrowRight']) dx = 1;

  const speed = S.player.speed * TILE / 60;
  const newPx = player.px + dx * speed, newPy = player.py + dy * speed;
  const ntx = Math.floor((newPx + TILE/2) / TILE), nty = Math.floor((newPy + TILE/2) / TILE);

  if (isWalkable(ntx, nty)) {
    player.px = Math.max(0, Math.min(newPx, (WW - 1) * TILE));
    player.py = Math.max(0, Math.min(newPy, (WH - 1) * TILE));
    player.tileX = Math.floor((player.px + TILE/2) / TILE);
    player.tileY = Math.floor((player.py + TILE/2) / TILE);
  }

  player.moving = (dx !== 0 || dy !== 0);
  if (player.moving) {
    if (dx !== 0) player.facingX = dx;
    if (dy !== 0) player.facingY = dy;
    player.frameTimer++;
    if (player.frameTimer > 8) { player.frame = (player.frame + 1) % 4; player.frameTimer = 0; }
  }

  // Space to use tool
  if (keys['Space']) {
    keys['Space'] = false;
    const fx = player.tileX + player.facingX, fy = player.tileY + player.facingY;
    if (inBounds(fx, fy)) handleTileClick(fx, fy, {});
  }

  // Camera follow
  const targetX = W/2 - (player.px + TILE/2) * camera.zoom;
  const targetY = H/2 - (player.py + TILE/2) * camera.zoom;
  const smooth = S.display.cameraSmooth;
  camera.x += (targetX - camera.x) * smooth;
  camera.y += (targetY - camera.y) * smooth;

  // Day/time
  tick++;
  if (tick >= TPDAY) {
    tick = 0; day++;
    const prevSeason = season;
    season = Math.floor((day - 1) / S.time.seasonLength) % SEASONS.length;
    rainDay = Math.random() < (S.time.rainChance[SEASONS[season]] || 0.2);
    refreshPrices();
    saveGame();

    const bannerEl = document.getElementById('day-banner');
    document.getElementById('day-banner-text').textContent = `Day ${day}`;
    document.getElementById('day-banner-sub').textContent = `${SEASONS[season]} â€¢ ${rainDay ? 'ğŸŒ§ Rainy Day' : 'â˜€ï¸ Clear Day'}`;
    bannerEl.classList.add('show');
    setTimeout(() => bannerEl.classList.remove('show'), 2500);

    if (season !== prevSeason) notify(`ğŸŒ¿ Season changed to ${SEASONS[season]}!`);
    if (rainDay) notify(`ğŸŒ§ It's raining! Crops will be watered today.`);
  }

  updateCrops();
  updateRobots();
  updateParticles();
  updateUI();
  animTime++;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * UI
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateUI() {
  document.getElementById('stat-coins').textContent = coins;
  document.getElementById('stat-day').textContent = day;
  document.getElementById('stat-season').textContent = SEASONS[season % SEASONS.length];
  const dp = tick / TPDAY;
  const timeName = dp < 0.2 ? 'ğŸŒ„ Dawn' : dp < 0.5 ? 'â˜€ï¸ Day' : dp < 0.7 ? 'ğŸŒ‡ Dusk' : 'ğŸŒ™ Night';
  document.getElementById('stat-time').textContent = timeName;

  for (const type of ['wheat','carrot','corn','sunflower','potato']) {
    const el = document.getElementById(`cnt-${type}`);
    if (el) el.textContent = inventory.seeds[type] || '';
  }
  checkMilestones();
}

function selectTool(tool) {
  currentTool = tool;
  document.querySelectorAll('.hslot').forEach(el => el.classList.remove('selected'));
  const el = document.querySelector(`[data-tool="${tool}"]`);
  if (el) el.classList.add('selected');
}

/* â”€â”€â”€ NOTIFICATIONS â”€â”€â”€ */
const notifQueue = [];
function notify(msg) {
  if (!S.display.showNotifications) return;
  const el = document.createElement('div');
  el.className = 'notif';
  el.textContent = msg;
  document.getElementById('notifications').prepend(el);
  setTimeout(() => { el.classList.add('fade'); setTimeout(() => el.remove(), 400); }, S.display.notificationDuration);
}

/* â”€â”€â”€ MODALS â”€â”€â”€ */
function openModal(id) {
  document.querySelectorAll('.modal-overlay').forEach(m => m.classList.add('hidden'));
  document.getElementById(`modal-${id}`).classList.remove('hidden');
  document.getElementById('crop-tooltip').style.display = 'none';
  syncCursorMode();
  if (id === 'shop') { buildShop(); buildSellGrid(); }
  if (id === 'robots') buildRobotList();
  if (id === 'files') openFilesModal();
}
function closeModal(id) { document.getElementById(`modal-${id}`).classList.add('hidden'); syncCursorMode(); }
function closeAllModals() { document.querySelectorAll('.modal-overlay').forEach(m => m.classList.add('hidden')); syncCursorMode(); }
function syncCursorMode() {
  const hasOpenModal = !!document.querySelector('.modal-overlay:not(.hidden)');
  document.body.classList.toggle('show-system-cursor', hasOpenModal);
  updateCursorCanvas();
}

function switchTab(modal, tab) {
  const m = document.getElementById(`modal-${modal}`);
  m.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
  m.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
  m.querySelector(`#${modal}-tab-${tab}`)?.classList.add('active');
  const btn = [...m.querySelectorAll('.tab-btn')].find(b => b.textContent.toLowerCase().includes(tab.split('_')[0]));
  if (btn) btn.classList.add('active');
}

/* â”€â”€â”€ SHOP â”€â”€â”€ */
function buildShop() {
  const grid = document.getElementById('seed-shop-grid');
  grid.innerHTML = '';
  for (const [type, cfg] of Object.entries(S.crops)) {
    const price = S.economy.seedPrices[type] || 5;
    const owned = inventory.seeds[type] || 0;
    const el = document.createElement('div');
    el.className = 'shop-item';
    el.innerHTML = `<span class="item-emoji">${cfg.emoji}</span><span class="item-name">${type}</span><span class="item-price">${price} coins/ea</span><span class="item-qty">Owned: ${owned} seeds</span>`;
    el.onclick = (e) => buySeeds(type, e.shiftKey ? 1 : 5);
    grid.appendChild(el);
  }
  document.getElementById('robot-price-display').textContent = `${S.economy.robotCost} coins`;
  document.getElementById('robot-count-display').textContent = `Owned: ${robotsOwned} â€¢ Placed: ${robots.length}`;
}

function buildSellGrid() {
  const grid = document.getElementById('sell-grid');
  grid.innerHTML = '';
  const hasCrops = Object.entries(inventory.crops).filter(([,v]) => v > 0);
  if (hasCrops.length === 0) {
    grid.innerHTML = '<div style="color:var(--text-dim);font-size:15px;padding:12px">No crops to sell yet. Get farming! ğŸŒ±</div>';
    return;
  }
  for (const [type, qty] of hasCrops) {
    const cfg = S.crops[type];
    const price = getCropPrice(type);
    const el = document.createElement('div');
    el.className = 'sell-item';
    el.innerHTML = `<span class="item-emoji">${cfg.emoji}</span><div class="sell-info"><div class="name">${type}</div><div class="count">${qty} units Â· ${price} ea</div></div><button class="sell-btn" onclick="sellCrop('${type}')">SELL</button>`;
    grid.appendChild(el);
  }
}

/* â”€â”€â”€ ROBOT LIST â”€â”€â”€ */
let configRobotId = null;

function buildRobotList() {
  const list = document.getElementById('robot-list');
  list.innerHTML = '';
  if (robots.length === 0) {
    list.innerHTML = '<div style="color:var(--text-dim);font-size:15px;padding:12px">No robots placed yet! Buy one at the Shop and place it with the Robot tool (key 9). ğŸ¤–</div>';
    document.getElementById('robot-config-panel').classList.remove('visible');
    return;
  }
  for (const bot of robots) {
    const bPct = bot.battery / S.robots.batteryMax * 100;
    const el = document.createElement('div');
    el.className = 'robot-list-item' + (bot.id === configRobotId ? ' selected' : '');
    el.innerHTML = `<span class="robot-icon">ğŸ¤–</span><div class="robot-info"><div class="robot-name">${bot.name} <span style="color:var(--text-dim);font-size:12px">[${bot.behavior}]</span></div><div class="robot-status">${bot.state} Â· ${bot.assignedCrop}</div><div class="battery-bar"><div class="battery-fill ${bPct < 20 ? 'low' : ''}" style="width:${bPct}%"></div></div></div>`;
    el.onclick = () => selectConfigRobot(bot.id);
    list.appendChild(el);
  }

  if (configRobotId || selectedRobotId) {
    const id = configRobotId || selectedRobotId;
    selectConfigRobot(id);
  }
}

function selectConfigRobot(id) {
  configRobotId = id;
  selectedRobotId = id;
  const bot = robots.find(r => r.id === id);
  if (!bot) return;

  const panel = document.getElementById('robot-config-panel');
  panel.classList.add('visible');
  document.getElementById('config-robot-name').textContent = bot.name;

  // Build behavior select
  const bs = document.getElementById('robot-behavior-select');
  bs.innerHTML = '';
  const allB = { ...builtinBehaviors, ...(S.customBehaviors || {}) };
  for (const name of Object.keys(allB)) {
    const opt = document.createElement('option');
    opt.value = name; opt.textContent = name;
    if (name === bot.behavior) opt.selected = true;
    bs.appendChild(opt);
  }

  document.getElementById('robot-crop-select').value = bot.assignedCrop || 'wheat';
  document.getElementById('robot-area-display').textContent = bot.workArea ? `(${bot.workArea.x}, ${bot.workArea.y}) r=${bot.workArea.radius}` : 'Not set';
  document.getElementById('robot-code-editor').value = bot.customCode || '';
  document.getElementById('code-error-msg').textContent = bot.codeError || '';

  document.querySelectorAll('.robot-list-item').forEach((el, i) => {
    el.classList.toggle('selected', robots[i]?.id === id);
  });
}

function applyRobotBehavior() {
  const bot = robots.find(r => r.id === configRobotId);
  if (bot) { bot.behavior = document.getElementById('robot-behavior-select').value; notify(`ğŸ¤– ${bot.name} behavior: ${bot.behavior}`); }
}

function applyRobotCrop() {
  const bot = robots.find(r => r.id === configRobotId);
  if (bot) { bot.assignedCrop = document.getElementById('robot-crop-select').value; }
}

function saveRobotCode() {
  const bot = robots.find(r => r.id === configRobotId);
  if (!bot) return;
  bot.customCode = document.getElementById('robot-code-editor').value;
  compileRobotCode(bot);
  if (bot.codeError) {
    document.getElementById('code-error-msg').textContent = `âŒ ${bot.codeError}`;
    notify(`âŒ Code error in ${bot.name}: ${bot.codeError}`);
  } else {
    document.getElementById('code-error-msg').textContent = '';
    notify(`âœ… ${bot.name} custom code saved!`);
  }
}

function clearRobotCode() {
  const bot = robots.find(r => r.id === configRobotId);
  if (!bot) return;
  bot.customCode = ''; bot.compiledCode = null; bot.codeError = '';
  document.getElementById('robot-code-editor').value = '';
  document.getElementById('code-error-msg').textContent = '';
  notify(`ğŸ—‘ ${bot.name} code cleared.`);
}

function deleteSelectedRobot() {
  const idx = robots.findIndex(r => r.id === configRobotId);
  if (idx === -1) return;
  const bot = robots[idx];
  if (!confirm(`Remove ${bot.name}? It will be returned to your inventory.`)) return;
  robotsOwned++; robots.splice(idx, 1);
  configRobotId = null; selectedRobotId = null;
  document.getElementById('robot-config-panel').classList.remove('visible');
  notify(`ğŸ¤– ${bot.name} returned to inventory.`);
  buildRobotList();
}

function startSetWorkArea() {
  closeAllModals();
  assigningWorkArea = true;
  document.getElementById('assign-overlay').classList.add('visible');
}

function cancelAssign() {
  assigningWorkArea = false;
  document.getElementById('assign-overlay').classList.remove('visible');
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * SECURE ROBOT CODE SANDBOX
 * Robot code runs here. Can see robot + api. Nothing else.
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const SANDBOX_BLOCKED = [
  'window','document','self','globalThis','parent','top','frames',
  'fetch','XMLHttpRequest','WebSocket','EventSource','Worker',
  'eval','Function','setTimeout','clearTimeout','setInterval','clearInterval',
  'requestAnimationFrame','cancelAnimationFrame','queueMicrotask',
  'navigator','location','history','screen','crypto',
  'localStorage','sessionStorage','indexedDB','caches',
  'performance','console','alert','confirm','prompt',
  'open','close','print','focus','blur',
];

function compileRobotCode(robot) {
  if (!robot.customCode || robot.customCode.trim() === '') { robot.compiledCode = null; robot.codeError = ''; return; }
  try {
    const fnArgs = [...SANDBOX_BLOCKED, 'robot', 'api'];
    robot.compiledCode = new Function(...fnArgs, '"use strict";\n' + robot.customCode);
    robot.codeError = '';
  } catch(e) { robot.compiledCode = null; robot.codeError = e.message; }
}

function runSandboxed(robot, fn) {
  const blockedVals = SANDBOX_BLOCKED.map(() => undefined);
  fn(...blockedVals, robot, robotAPI);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * WORLD FILE EXPORT / IMPORT  (Feature 6)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function buildSaveObject() {
  return {
    v: 2, coins, day, tick, season, isRaining, rainDay, inventory, robotsOwned,
    nextRobotId, priceMultipliers,
    robots: robots.map(r => ({
      id: r.id, name: r.name, tileX: r.tileX, tileY: r.tileY,
      homeTileX: r.homeTileX, homeTileY: r.homeTileY,
      battery: r.battery, behavior: r.behavior, assignedCrop: r.assignedCrop,
      workArea: r.workArea, inventory: r.inventory, memory: r.memory, customCode: r.customCode,
    })),
    world: world.map(row => row.map(t => ({
      type: t.type, crop: t.crop ? { ...t.crop } : null, watered: t.watered
    })))
  };
}

function downloadFile(content, filename, mime) {
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function exportWorldFile() {
  const save = buildSaveObject();
  const dateStr = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  const cropCount = world.flat().filter(t => t.crop).length;
  const content =
`// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘            ROBO FARM  â€”  World Save File                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
//  Farm: Day ${day}  |  Season: ${SEASONS[season % SEASONS.length]}  |  Coins: ${coins}
//  Robots placed: ${robots.length}  |  Crops in ground: ${cropCount}
//  Exported: ${dateStr}
//
//  â”€â”€â”€ HOW TO RESTORE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  1. Open index.html in your browser
//  2. Click [ğŸ“ Files] in the top bar
//  3. Click "Import World File" and select this file
//  4. Your farm is back â€” exactly where you left it!
//
//  â”€â”€â”€ DO NOT EDIT THE DATA BELOW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

window.__ROBOFARM_IMPORT__ = ${JSON.stringify(save, null, 2)};
`;
  downloadFile(content, `robofarm-day${day}.js`, 'text/javascript');
  notify('ğŸ“ World file downloaded!');
}

function handleWorldImportFile(input) {
  const file = input.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const text = e.target.result;
      const match = text.match(/window\.__ROBOFARM_IMPORT__\s*=\s*(\{[\s\S]+\})\s*;?\s*$/m);
      if (!match) { notify('âŒ Not a valid Robo Farm world file!'); return; }
      const save = JSON.parse(match[1]);
      if (!save || save.v !== 2) { notify('âŒ Incompatible save version!'); return; }
      applyGameSave(save);
      notify('ğŸŒ¾ Farm restored! Welcome back, farmer.');
      closeModal('files');
    } catch(err) { notify('âŒ Could not read file: ' + err.message); }
  };
  reader.readAsText(file);
  input.value = '';
}

function applyGameSave(save) {
  coins = save.coins; day = save.day; tick = save.tick; season = save.season;
  isRaining = save.isRaining; rainDay = save.rainDay; inventory = save.inventory;
  robotsOwned = save.robotsOwned; nextRobotId = save.nextRobotId; priceMultipliers = save.priceMultipliers;
  for (let y = 0; y < WH; y++) for (let x = 0; x < WW; x++) {
    if (save.world[y] && save.world[y][x]) {
      world[y][x].type = save.world[y][x].type;
      world[y][x].crop = save.world[y][x].crop;
      world[y][x].watered = save.world[y][x].watered || false;
    }
  }
  robots = [];
  for (const rd of save.robots) {
    const bot = new Robot(rd.tileX, rd.tileY);
    Object.assign(bot, rd);
    bot.px = bot.tileX * TILE; bot.py = bot.tileY * TILE;
    bot.path = []; bot._pendingAction = null; bot.actionTimer = 0; bot.workTimer = 0;
    if (bot.customCode) compileRobotCode(bot);
    robots.push(bot);
  }
  updateUI();
}

function openModal_files() { /* wrapper */ openModal('files'); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ROBOT CODE FILE EXPORT / IMPORT  (Feature 12)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function exportRobotCode() {
  const bot = robots.find(r => r.id === configRobotId);
  if (!bot) { notify('âŒ Select a robot first!'); return; }
  const code = document.getElementById('robot-code-editor').value.trim() ||
    '// No code yet â€” write your behavior here!\n// See the API Reference in the editor for all available commands.';
  const content =
`// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘          ROBO FARM  â€”  Robot Behavior File                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
//  Robot:    ${bot.name}
//  Behavior: ${bot.behavior}
//
//  â”€â”€â”€ HOW TO USE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Option A: Paste into the robot's code editor in-game
//  Option B: Add to customBehaviors in settings.js:
//
//    'My Behavior': function(robot, api) {
//      // paste the code below here
//    },
//
//  â”€â”€â”€ API QUICK REFERENCE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  api.pos(robot)               â†’ {x, y}
//  api.findCrop(robot, filter)  â†’ crop tile | null
//    filter: { ready?, needsWater?, type?, maxDist?, cx?, cy? }
//  api.findTile(robot, filter)  â†’ tile | null
//    filter: { tileType?, empty?, maxDist? }
//  api.moveTo(robot, x, y)      â†’ walk toward tile
//  api.water(robot, x, y)       â†’ water crop
//  api.harvest(robot, x, y)     â†’ harvest ready crop
//  api.plant(robot, x, y, type) â†’ plant seed
//  api.till(robot, x, y)        â†’ hoe grass/flower
//  api.idle(robot)              â†’ do nothing
//  api.mem(robot, key, val?)    â†’ get/set persistent memory
//  api.inventory(robot)         â†’ {seeds:{...}, crops:{...}}
//  api.nearby(robot, radius)    â†’ array of nearby tiles
//  robot.assignedCrop           â†’ crop type from UI panel
//  robot.workArea               â†’ {x, y, radius} | null
//
//  âš ï¸  Runs in a secure sandbox â€” no browser APIs available.
//     Just robot, api, and your logic.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

${code}
`;
  const safeName = bot.name.toLowerCase().replace(/[^a-z0-9]/g, '-');
  downloadFile(content, `${safeName}-behavior.js`, 'text/javascript');
  notify(`ğŸ“¤ ${bot.name} code exported!`);
}

function handleRobotImportFile(input) {
  const file = input.files[0];
  if (!file) return;
  const bot = robots.find(r => r.id === configRobotId);
  if (!bot) { notify('âŒ Select a robot first!'); return; }
  const reader = new FileReader();
  reader.onload = e => {
    const text = e.target.result;
    // Strip comment header if present, find actual code
    const lines = text.split('\n');
    const codeLines = [];
    let pastHeader = false;
    for (const line of lines) {
      if (!pastHeader && line.startsWith('//')) continue;
      if (!pastHeader && line.trim() === '') continue;
      pastHeader = true;
      codeLines.push(line);
    }
    const code = codeLines.join('\n').trim();
    document.getElementById('robot-code-editor').value = code;
    notify(`ğŸ“¥ Code imported into ${bot.name}! Hit Save to apply.`);
  };
  reader.readAsText(file);
  input.value = '';
}

/* â”€â”€â”€ CODE EDITOR TEMPLATES â”€â”€â”€ */
const CODE_TEMPLATES = {
  blank: `// Your robot's brain goes here.
// This code runs every ${window.GAME_SETTINGS?.robots?.workDelay || 40} game ticks.

api.idle(robot);`,

  waterer: `// Smart Waterer
// Finds the nearest thirsty crop and waters it.
const t = api.findCrop(robot, { needsWater: true, maxDist: 10 });
if (t) {
  api.moveTo(robot, t.x, t.y);
  api.water(robot, t.x, t.y);
} else {
  api.idle(robot);
}`,

  fullcycle: `// Full Cycle Farmer
// Priority: Harvest â†’ Water â†’ Plant
const max = robot.workArea?.radius || 12;
const cx = robot.workArea?.x, cy = robot.workArea?.y;

const ready = api.findCrop(robot, { ready: true, maxDist: max, cx, cy });
if (ready) { api.moveTo(robot, ready.x, ready.y); api.harvest(robot, ready.x, ready.y); return; }

const thirsty = api.findCrop(robot, { needsWater: true, maxDist: max, cx, cy });
if (thirsty) { api.moveTo(robot, thirsty.x, thirsty.y); api.water(robot, thirsty.x, thirsty.y); return; }

const crop = robot.assignedCrop || 'wheat';
const empty = api.findTile(robot, { tileType: 'tilled', empty: true, maxDist: max, cx, cy });
if (empty) { api.moveTo(robot, empty.x, empty.y); api.plant(robot, empty.x, empty.y, crop); return; }

api.idle(robot);`,

  zone: `// Zone Farmer â€” stays within assigned work area
// Set the area using the "Set Area" button in the panel!
if (!robot.workArea) { api.idle(robot); return; }

const { x: cx, y: cy, radius } = robot.workArea;

const ready = api.findCrop(robot, { ready: true, maxDist: radius, cx, cy });
if (ready) { api.moveTo(robot, ready.x, ready.y); api.harvest(robot, ready.x, ready.y); return; }

const thirsty = api.findCrop(robot, { needsWater: true, maxDist: radius, cx, cy });
if (thirsty) { api.moveTo(robot, thirsty.x, thirsty.y); api.water(robot, thirsty.x, thirsty.y); return; }

const crop = robot.assignedCrop || 'wheat';
const empty = api.findTile(robot, { tileType: 'tilled', empty: true, maxDist: radius, cx, cy });
if (empty) { api.moveTo(robot, empty.x, empty.y); api.plant(robot, empty.x, empty.y, crop); return; }

api.idle(robot);`,

  patrol: `// Scout â€” wanders and waters anything it finds
// Uses memory to spiral outward from home position
const mem = api.mem;
if (!mem(robot, 'angle')) { mem(robot, 'angle', 0); mem(robot, 'r', 2); }

const thirsty = api.findCrop(robot, { needsWater: true, maxDist: 14 });
if (thirsty) { api.moveTo(robot, thirsty.x, thirsty.y); api.water(robot, thirsty.x, thirsty.y); return; }

// Wander when nothing to water
let angle = mem(robot, 'angle');
const r = mem(robot, 'r');
const { x, y } = api.pos(robot);
const tx = Math.round(robot.homeTileX + Math.cos(angle) * r);
const ty = Math.round(robot.homeTileY + Math.sin(angle) * r);
api.moveTo(robot, tx, ty);
mem(robot, 'angle', angle + 0.7);
if (angle > Math.PI * 2) { mem(robot, 'angle', 0); mem(robot, 'r', (r % 8) + 1); }`,
};

function toggleTemplateMenu() {
  document.getElementById('template-menu').classList.toggle('visible');
}

function applyTemplate(name) {
  const code = CODE_TEMPLATES[name] || '';
  document.getElementById('robot-code-editor').value = code;
  document.getElementById('template-menu').classList.remove('visible');
}

function toggleApiRef() {
  const body = document.getElementById('api-ref-body');
  const arrow = document.getElementById('api-ref-arrow');
  body.classList.toggle('visible');
  arrow.textContent = body.classList.contains('visible') ? 'â–¼' : 'â–¶';
}

// Close template menu on outside click
document.addEventListener('click', e => {
  if (!e.target.closest('.code-toolbar')) document.getElementById('template-menu')?.classList.remove('visible');
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * DRAG-TO-USE TOOLS  (QoL â€” hold mouse to apply tool to multiple tiles)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let mouseIsDown = false;
let lastDragTile = { x: -1, y: -1 };

canvas.addEventListener('mousedown', e => {
  mouseIsDown = true;
  lastDragTile = { x: -1, y: -1 };
});
document.addEventListener('mouseup', () => { mouseIsDown = false; });

canvas.addEventListener('mousemove', e => {
  if (!mouseIsDown) return;
  const tx = Math.floor(mouseWorld.x / TILE);
  const ty = Math.floor(mouseWorld.y / TILE);
  if (tx === lastDragTile.x && ty === lastDragTile.y) return;
  lastDragTile = { x: tx, y: ty };
  // Only drag-apply for till, water, and seeds (not hand or robot_place)
  if (currentTool === 'hoe' || currentTool === 'water' || S.crops[currentTool]) {
    if (inBounds(tx, ty)) handleTileClick(tx, ty, {});
  }
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * CROP HOVER TOOLTIP  (QoL â€” hover to see crop info)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateCropTooltip(mx, my) {
  const tooltip = document.getElementById('crop-tooltip');
  const tx = Math.floor(mouseWorld.x / TILE);
  const ty = Math.floor(mouseWorld.y / TILE);

  if (!inBounds(tx, ty) || !world[ty][tx].crop) {
    tooltip.style.display = 'none'; return;
  }

  const crop = world[ty][tx].crop;
  const cfg = S.crops[crop.type];
  if (!cfg) { tooltip.style.display = 'none'; return; }

  const isReady = crop.stage >= cfg.stages - 1;
  const stagePct = (crop.stage / (cfg.stages - 1)) * 100;
  const waterPct = Math.min(100, (crop.waterCount / cfg.waterNeeded) * 100);

  document.getElementById('ct-name').textContent = `${cfg.emoji} ${crop.type.toUpperCase()}`;
  document.getElementById('ct-stage').innerHTML =
    `Stage ${crop.stage + 1}/${cfg.stages}  Â·  ğŸ’§ ${crop.waterCount}/${cfg.waterNeeded}`;
  document.getElementById('ct-fill').style.width = stagePct + '%';
  const readyEl = document.getElementById('ct-ready');
  readyEl.style.display = isReady ? 'block' : 'none';

  const pad = 12;
  tooltip.style.left = (mx + pad) + 'px';
  tooltip.style.top = (my - tooltip.offsetHeight / 2) + 'px';
  tooltip.style.display = 'block';
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * MILESTONE SYSTEM  (QoL â€” celebrate small victories)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let milestones = { firstHarvest: false, firstRobot: false, crops100: false, coins1000: false, crops500: false };

function checkMilestones() {
  const totalCrops = Object.values(inventory.crops).reduce((a, b) => a + b, 0);

  if (!milestones.firstHarvest && totalCrops > 0) {
    milestones.firstHarvest = true;
    showMilestone('FIRST HARVEST!', 'You grew something. That\'s real. That\'s yours. ğŸŒ¾');
  }
  if (!milestones.firstRobot && robots.length > 0) {
    milestones.firstRobot = true;
    showMilestone('FIRST ROBOT!', 'Your farm will never sleep again. ğŸ¤–');
  }
  if (!milestones.crops100 && totalCrops >= 100) {
    milestones.crops100 = true;
    showMilestone('100 CROPS!', 'A proper operation is taking shape. Keep going!');
  }
  if (!milestones.coins1000 && coins >= 1000) {
    milestones.coins1000 = true;
    showMilestone('1000 COINS!', 'Look at that bank account grow. ğŸ’°');
  }
}

function showMilestone(title, sub) {
  document.getElementById('milestone-text').textContent = title;
  document.getElementById('milestone-sub').textContent = sub;
  const el = document.getElementById('milestone-banner');
  el.style.opacity = '1';
  setTimeout(() => el.style.opacity = '0', 3200);
}

/* â”€â”€â”€ FILES MODAL helper â”€â”€â”€ */
function openFilesModal() {
  const info = document.getElementById('files-farm-info');
  const cropCount = world.flat().filter(t => t.crop).length;
  info.textContent = `Day ${day}  Â·  ${SEASONS[season % SEASONS.length]}  Â·  ${coins} coins  Â·  ${robots.length} robots  Â·  ${cropCount} crops planted`;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * MAIN GAME LOOP
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * INIT
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
window.addEventListener('resize', resize);
resize();
generateWorld();

const loaded = loadGame();
if (!loaded) {
  notify('ğŸŒ¾ Welcome to Robo Farm! Press F for the guide.');
  notify('ğŸŒ± Start by tilling soil (key 2) and planting seeds!');
  rainDay = Math.random() < S.time.rainChance['Spring'];
  setTimeout(() => {
    openModal('changelog');
  }, 600);
} else {
  // Show changelog once per version update
  const lastSeen = localStorage.getItem('roboFarm_changelogSeen');
  if (lastSeen !== 'v0.2') {
    setTimeout(() => { openModal('changelog'); localStorage.setItem('roboFarm_changelogSeen', 'v0.2'); }, 400);
  }
}

// Place starter robots if any
for (let i = 0; i < S.player.startRobots; i++) {
  const bot = new Robot(S.player.startX + 2 + i, S.player.startY + 2);
  robots.push(bot);
}

// Camera init
camera.x = window.innerWidth/2 - (player.px + TILE/2) * camera.zoom;
camera.y = window.innerHeight/2 - (player.py + TILE/2) * camera.zoom;

updateUI();
loop();

/* Click outside modals to close */
document.querySelectorAll('.modal-overlay').forEach(overlay => {
  overlay.addEventListener('click', function(e) {
    if (e.target === this) { this.classList.add('hidden'); syncCursorMode(); }
  });
});
</script>
</body>
</html>
