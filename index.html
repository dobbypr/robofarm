<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üåæ Robo Farm</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323:wght@400&family=Silkscreen&display=swap" rel="stylesheet">
<script src="settings.js"></script>
<style>
:root {
  --gold: #f5c842;
  --gold-dim: #c9973a;
  --ui-bg: rgba(18, 14, 8, 0.92);
  --ui-border: #5a3e1a;
  --ui-border-bright: #c9973a;
  --text: #f0e8d0;
  --text-dim: #998877;
  --green: #4a9c3f;
  --red: #c44040;
  --blue: #3a7abb;
  --panel-bg: rgba(12, 10, 5, 0.96);
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { overflow: hidden; background: #1a2010; font-family: 'VT323', monospace; cursor: none; }
canvas#game { display: block; position: fixed; top: 0; left: 0; image-rendering: pixelated; }
canvas#cursor-canvas { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1000; }

/* ‚îÄ‚îÄ‚îÄ TOP BAR ‚îÄ‚îÄ‚îÄ */
#topbar {
  position: fixed; top: 0; left: 0; right: 0; height: 44px;
  background: var(--ui-bg); border-bottom: 2px solid var(--ui-border);
  display: flex; align-items: center; padding: 0 12px; gap: 16px; z-index: 200;
  font-family: 'Press Start 2P', monospace; font-size: 8px;
}
#game-title { color: var(--gold); letter-spacing: 1px; white-space: nowrap; }
.stat-block { display: flex; align-items: center; gap: 5px; color: var(--text); }
.stat-block .val { color: var(--gold); min-width: 40px; }
#topbar-right { margin-left: auto; display: flex; gap: 6px; }
.top-btn {
  background: var(--ui-bg); border: 1px solid var(--ui-border);
  color: var(--text); font-family: 'Press Start 2P', monospace; font-size: 7px;
  padding: 5px 8px; cursor: pointer; transition: all 0.1s;
}
.top-btn:hover { border-color: var(--gold); color: var(--gold); background: rgba(200,150,50,0.15); }
.top-btn.active { border-color: var(--gold); color: var(--gold); background: rgba(200,150,50,0.2); }

/* ‚îÄ‚îÄ‚îÄ HOTBAR ‚îÄ‚îÄ‚îÄ */
#hotbar {
  position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 4px; z-index: 200;
  background: var(--ui-bg); border: 2px solid var(--ui-border);
  padding: 6px 8px; border-radius: 2px;
}
.hslot {
  width: 44px; height: 44px; border: 2px solid #3a2a0e;
  background: rgba(0,0,0,0.5); display: flex; flex-direction: column;
  align-items: center; justify-content: center; cursor: pointer;
  position: relative; transition: border-color 0.1s;
  font-size: 20px; color: var(--text);
}
.hslot:hover { border-color: var(--ui-border-bright); }
.hslot.selected { border-color: var(--gold); box-shadow: 0 0 8px rgba(245,200,66,0.4); }
.hslot .key-hint { position: absolute; top: 1px; left: 3px; font-family: 'Press Start 2P', monospace; font-size: 5px; color: var(--text-dim); }
.hslot .count { position: absolute; bottom: 1px; right: 3px; font-family: 'Press Start 2P', monospace; font-size: 6px; color: var(--gold); }
.hslot .lbl { font-size: 8px; font-family: 'VT323', monospace; color: var(--text-dim); margin-top: -2px; }

/* ‚îÄ‚îÄ‚îÄ MODALS ‚îÄ‚îÄ‚îÄ */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 500;
  display: flex; align-items: center; justify-content: center;
}
.modal-overlay.hidden { display: none; }
.modal {
  background: var(--panel-bg); border: 2px solid var(--ui-border-bright);
  min-width: 480px; max-width: 700px; max-height: 80vh; overflow: hidden;
  display: flex; flex-direction: column;
}
.modal-header {
  background: rgba(90,62,26,0.5); padding: 10px 14px;
  display: flex; align-items: center; justify-content: space-between;
  border-bottom: 1px solid var(--ui-border);
}
.modal-title { color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 10px; }
.modal-close { color: var(--text-dim); font-size: 20px; cursor: pointer; font-family: 'VT323', monospace; }
.modal-close:hover { color: var(--red); }
.modal-body { padding: 14px; overflow-y: auto; flex: 1; }
.modal-tabs { display: flex; border-bottom: 1px solid var(--ui-border); margin-bottom: 12px; }
.tab-btn {
  padding: 6px 14px; cursor: pointer; color: var(--text-dim);
  font-family: 'Press Start 2P', monospace; font-size: 8px;
  border: none; background: transparent;
  border-bottom: 2px solid transparent; margin-bottom: -1px;
}
.tab-btn:hover { color: var(--text); }
.tab-btn.active { color: var(--gold); border-bottom-color: var(--gold); }
.tab-content { display: none; }
.tab-content.active { display: block; }

/* ‚îÄ‚îÄ‚îÄ SHOP ‚îÄ‚îÄ‚îÄ */
.shop-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
.shop-item {
  border: 1px solid var(--ui-border); padding: 10px; text-align: center;
  cursor: pointer; transition: all 0.15s; background: rgba(0,0,0,0.3);
}
.shop-item:hover { border-color: var(--gold); background: rgba(200,150,50,0.1); }
.shop-item .item-emoji { font-size: 28px; display: block; margin-bottom: 4px; }
.shop-item .item-name { color: var(--text); font-size: 14px; display: block; }
.shop-item .item-price { color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 8px; display: block; margin-top: 4px; }
.shop-item .item-qty { color: var(--text-dim); font-size: 12px; margin-top: 2px; display: block; }
.sell-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.sell-item { border: 1px solid var(--ui-border); padding: 8px; background: rgba(0,0,0,0.3); display: flex; align-items: center; gap: 8px; }
.sell-item .item-emoji { font-size: 22px; }
.sell-info { flex: 1; }
.sell-info .name { color: var(--text); font-size: 16px; }
.sell-info .count { color: var(--text-dim); font-size: 13px; }
.sell-btn { background: var(--green); border: none; color: white; font-family: 'Press Start 2P', monospace; font-size: 7px; padding: 5px 8px; cursor: pointer; }
.sell-btn:hover { opacity: 0.85; }
.sell-all-btn { background: var(--gold-dim); border: none; color: #1a1000; font-family: 'Press Start 2P', monospace; font-size: 7px; padding: 5px 8px; cursor: pointer; margin-top: 8px; width: 100%; }

/* ‚îÄ‚îÄ‚îÄ ROBOT PANEL ‚îÄ‚îÄ‚îÄ */
.robot-list-item {
  border: 1px solid var(--ui-border); padding: 8px 10px; margin-bottom: 6px;
  cursor: pointer; display: flex; align-items: center; gap: 10px; transition: border-color 0.1s;
}
.robot-list-item:hover, .robot-list-item.selected { border-color: var(--gold); }
.robot-icon { font-size: 24px; }
.robot-info { flex: 1; }
.robot-name { color: var(--text); font-size: 16px; }
.robot-status { color: var(--text-dim); font-size: 13px; }
.battery-bar { height: 4px; background: #222; margin-top: 4px; border: 1px solid #333; }
.battery-fill { height: 100%; background: var(--green); transition: width 0.3s; }
.battery-fill.low { background: var(--red); }
.robot-detail-panel { border: 1px solid var(--ui-border); padding: 12px; margin-top: 8px; background: rgba(0,0,0,0.3); display: none; }
.robot-detail-panel.visible { display: block; }
.detail-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.detail-label { color: var(--text-dim); font-family: 'Press Start 2P', monospace; font-size: 7px; width: 100px; }
.detail-value { color: var(--text); font-size: 15px; flex: 1; }
select.game-select, input.game-input {
  background: rgba(0,0,0,0.5); border: 1px solid var(--ui-border);
  color: var(--text); font-family: 'VT323', monospace; font-size: 16px; padding: 3px 6px; width: 100%;
}
select.game-select:focus, input.game-input:focus { border-color: var(--gold); outline: none; }
textarea.code-area {
  background: #0a0c08; border: 1px solid var(--ui-border);
  color: #7fff7f; font-family: 'Courier New', monospace; font-size: 12px;
  padding: 8px; width: 100%; height: 180px; resize: vertical; line-height: 1.5;
}
textarea.code-area:focus { border-color: var(--green); outline: none; }
.code-error { color: var(--red); font-size: 13px; margin-top: 4px; font-family: 'VT323', monospace; }

/* ‚îÄ‚îÄ‚îÄ DOCS ‚îÄ‚îÄ‚îÄ */
.docs-body { color: var(--text); font-size: 16px; line-height: 1.7; }
.docs-body h2 { color: var(--gold); font-family: 'Press Start 2P', monospace; font-size: 9px; margin: 16px 0 8px; }
.docs-body h3 { color: var(--gold-dim); font-family: 'Press Start 2P', monospace; font-size: 7px; margin: 12px 0 6px; }
.docs-body p { margin-bottom: 8px; color: var(--text-dim); }
.docs-body p strong { color: var(--text); }
.docs-body code { background: rgba(0,0,0,0.5); color: #7fff7f; padding: 1px 5px; font-family: 'Courier New', monospace; font-size: 12px; }
.docs-body .tip { border-left: 3px solid var(--gold); padding: 6px 10px; margin: 8px 0; background: rgba(245,200,66,0.07); }
.docs-body .key { display: inline-block; background: #2a2010; border: 1px solid var(--ui-border); padding: 1px 5px; font-family: 'Press Start 2P', monospace; font-size: 7px; }

/* ‚îÄ‚îÄ‚îÄ NOTIFICATIONS ‚îÄ‚îÄ‚îÄ */
#notifications { position: fixed; top: 56px; right: 12px; z-index: 600; display: flex; flex-direction: column; gap: 4px; pointer-events: none; }
.notif {
  background: var(--ui-bg); border: 1px solid var(--ui-border-bright);
  color: var(--text); font-size: 15px; padding: 7px 12px;
  animation: notifIn 0.2s ease; max-width: 260px;
}
.notif.fade { animation: notifOut 0.4s ease forwards; }
@keyframes notifIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
@keyframes notifOut { to { opacity: 0; transform: translateX(20px); } }

/* ‚îÄ‚îÄ‚îÄ ROBOT TOOLTIP ‚îÄ‚îÄ‚îÄ */
#robot-tooltip {
  position: fixed; z-index: 300; pointer-events: none;
  background: var(--ui-bg); border: 1px solid var(--ui-border-bright);
  padding: 6px 10px; font-size: 13px; color: var(--text); display: none;
}

/* ‚îÄ‚îÄ‚îÄ GAME BUTTONS ‚îÄ‚îÄ‚îÄ */
.game-btn {
  background: rgba(90,62,26,0.7); border: 1px solid var(--ui-border);
  color: var(--text); font-family: 'Press Start 2P', monospace; font-size: 7px;
  padding: 7px 10px; cursor: pointer; transition: all 0.1s;
}
.game-btn:hover { border-color: var(--gold); color: var(--gold); }
.game-btn.primary { background: rgba(100,70,20,0.8); border-color: var(--gold-dim); color: var(--gold); }
.game-btn.danger { border-color: #8a3030; color: #ff8080; }
.game-btn.success { border-color: #306830; color: #80ff80; }

/* ‚îÄ‚îÄ‚îÄ ASSIGN OVERLAY ‚îÄ‚îÄ‚îÄ */
#assign-overlay {
  position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
  background: var(--ui-bg); border: 2px solid var(--gold);
  padding: 10px 16px; z-index: 300; display: none;
  font-family: 'Press Start 2P', monospace; font-size: 8px; color: var(--gold);
  text-align: center;
}
#assign-overlay.visible { display: block; }

/* ‚îÄ‚îÄ‚îÄ DAY TRANSITION ‚îÄ‚îÄ‚îÄ */
#day-banner {
  position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
  z-index: 800; pointer-events: none; opacity: 0;
  transition: opacity 0.5s;
}
#day-banner.show { opacity: 1; }
#day-banner-inner {
  background: var(--ui-bg); border: 2px solid var(--gold);
  padding: 20px 40px; text-align: center;
}
#day-banner-text { font-family: 'Press Start 2P', monospace; color: var(--gold); font-size: 16px; }
#day-banner-sub { color: var(--text-dim); font-size: 18px; margin-top: 6px; }
</style>
</head>
<body>

<!-- Canvases -->
<canvas id="game"></canvas>
<canvas id="cursor-canvas"></canvas>

<!-- Top Bar -->
<div id="topbar">
  <div id="game-title">üåæ ROBO FARM</div>
  <div class="stat-block">üí∞ <span id="stat-coins" class="val">250</span></div>
  <div class="stat-block">üìÖ Day <span id="stat-day" class="val">1</span></div>
  <div class="stat-block" id="stat-season-block">üå∏ <span id="stat-season" class="val">Spring</span></div>
  <div class="stat-block">‚è∞ <span id="stat-time" class="val">Morning</span></div>
  <div id="topbar-right">
    <button class="top-btn" onclick="openModal('shop')">üè™ Shop</button>
    <button class="top-btn" onclick="openModal('robots')">ü§ñ Robots</button>
    <button class="top-btn" onclick="openModal('docs')">üìñ Docs</button>
    <button class="top-btn" onclick="saveGame()" title="Save Game">üíæ</button>
  </div>
</div>

<!-- Hotbar -->
<div id="hotbar">
  <div class="hslot selected" data-tool="hand" onclick="selectTool('hand')">
    <span class="key-hint">1</span>‚úã<span class="lbl">Hand</span>
  </div>
  <div class="hslot" data-tool="hoe" onclick="selectTool('hoe')">
    <span class="key-hint">2</span>‚õèÔ∏è<span class="lbl">Hoe</span>
  </div>
  <div class="hslot" data-tool="water" onclick="selectTool('water')">
    <span class="key-hint">3</span>üíß<span class="lbl">Water</span>
  </div>
  <div class="hslot seed-slot" data-tool="wheat" onclick="selectTool('wheat')">
    <span class="key-hint">4</span>üåæ<span class="lbl">Wheat</span><span class="count" id="cnt-wheat">0</span>
  </div>
  <div class="hslot seed-slot" data-tool="carrot" onclick="selectTool('carrot')">
    <span class="key-hint">5</span>ü•ï<span class="lbl">Carrot</span><span class="count" id="cnt-carrot">0</span>
  </div>
  <div class="hslot seed-slot" data-tool="corn" onclick="selectTool('corn')">
    <span class="key-hint">6</span>üåΩ<span class="lbl">Corn</span><span class="count" id="cnt-corn">0</span>
  </div>
  <div class="hslot seed-slot" data-tool="sunflower" onclick="selectTool('sunflower')">
    <span class="key-hint">7</span>üåª<span class="lbl">Sun</span><span class="count" id="cnt-sunflower">0</span>
  </div>
  <div class="hslot seed-slot" data-tool="potato" onclick="selectTool('potato')">
    <span class="key-hint">8</span>ü•î<span class="lbl">Potato</span><span class="count" id="cnt-potato">0</span>
  </div>
  <div class="hslot" data-tool="robot_place" onclick="selectTool('robot_place')">
    <span class="key-hint">9</span>ü§ñ<span class="lbl">Bot</span>
  </div>
</div>

<!-- Assign Overlay -->
<div id="assign-overlay">üéØ CLICK A TILE TO SET WORK AREA<br><small style="font-size:6px;margin-top:4px;display:block">ESC to cancel</small></div>

<!-- Robot Tooltip -->
<div id="robot-tooltip"></div>

<!-- Day Banner -->
<div id="day-banner"><div id="day-banner-inner"><div id="day-banner-text"></div><div id="day-banner-sub"></div></div></div>

<!-- Notifications -->
<div id="notifications"></div>

<!-- SHOP MODAL -->
<div class="modal-overlay hidden" id="modal-shop">
<div class="modal" style="width:600px">
  <div class="modal-header">
    <span class="modal-title">üè™ MARKET & SHOP</span>
    <span class="modal-close" onclick="closeModal('shop')">‚úï</span>
  </div>
  <div class="modal-body">
    <div class="modal-tabs">
      <button class="tab-btn active" onclick="switchTab('shop','buy')">Buy Seeds</button>
      <button class="tab-btn" onclick="switchTab('shop','equipment')">Equipment</button>
      <button class="tab-btn" onclick="switchTab('shop','sell')">Sell Crops</button>
    </div>
    <div id="shop-tab-buy" class="tab-content active">
      <div style="color:var(--text-dim);font-size:13px;margin-bottom:10px">Click a seed to buy 5 at a time. Hold Shift to buy 1.</div>
      <div class="shop-grid" id="seed-shop-grid"></div>
    </div>
    <div id="shop-tab-equipment" class="tab-content">
      <div class="shop-grid">
        <div class="shop-item" onclick="buyRobot()">
          <span class="item-emoji">ü§ñ</span>
          <span class="item-name">Robot</span>
          <span class="item-price" id="robot-price-display">200 coins</span>
          <span class="item-qty" id="robot-count-display">Owned: 0</span>
        </div>
      </div>
      <div style="color:var(--text-dim);font-size:13px;margin-top:12px;padding:8px;border:1px solid var(--ui-border)">
        ü§ñ Robots automate your farm! Place them with the Robot tool (key 9), then click them to assign tasks. You can even write custom AI in <code>settings.js</code>!
      </div>
    </div>
    <div id="shop-tab-sell" class="tab-content">
      <div style="color:var(--text-dim);font-size:13px;margin-bottom:10px">Sell your harvested crops here. Sell all at once for the best value!</div>
      <div class="sell-grid" id="sell-grid"></div>
      <button class="sell-all-btn" onclick="sellAll()">üí∞ SELL ALL CROPS</button>
    </div>
  </div>
</div>
</div>

<!-- ROBOTS MODAL -->
<div class="modal-overlay hidden" id="modal-robots">
<div class="modal" style="width:580px">
  <div class="modal-header">
    <span class="modal-title">ü§ñ ROBOT MANAGER</span>
    <span class="modal-close" onclick="closeModal('robots')">‚úï</span>
  </div>
  <div class="modal-body">
    <div style="color:var(--text-dim);font-size:13px;margin-bottom:10px">Select a robot to configure it. Or use the Robot tool to place/select them on the map!</div>
    <div id="robot-list"></div>
    <div id="robot-config-panel" class="robot-detail-panel">
      <div style="color:var(--gold);font-family:'Press Start 2P',monospace;font-size:9px;margin-bottom:10px" id="config-robot-name">BOT-1</div>
      <div class="detail-row">
        <span class="detail-label">BEHAVIOR</span>
        <select class="game-select" id="robot-behavior-select" onchange="applyRobotBehavior()"></select>
      </div>
      <div class="detail-row">
        <span class="detail-label">PLANT CROP</span>
        <select class="game-select" id="robot-crop-select" onchange="applyRobotCrop()">
          <option value="wheat">üåæ Wheat</option>
          <option value="carrot">ü•ï Carrot</option>
          <option value="corn">üåΩ Corn</option>
          <option value="sunflower">üåª Sunflower</option>
          <option value="potato">ü•î Potato</option>
          <option value="tomato">üçÖ Tomato</option>
        </select>
      </div>
      <div class="detail-row">
        <span class="detail-label">WORK AREA</span>
        <span class="detail-value" id="robot-area-display" style="color:var(--text-dim);font-size:14px">Not set</span>
        <button class="game-btn" onclick="startSetWorkArea()" style="font-size:7px">Set Area</button>
      </div>
      <div style="margin-top:10px">
        <div style="color:var(--gold-dim);font-family:'Press Start 2P',monospace;font-size:7px;margin-bottom:6px">‚ö° CUSTOM JS CODE (optional)</div>
        <div style="color:var(--text-dim);font-size:12px;margin-bottom:6px">Override with your own behavior. Leave blank to use the selected behavior above.</div>
        <textarea class="code-area" id="robot-code-editor" placeholder="// Write your robot's brain here!
// function(robot, api) body:

const target = api.findCrop(robot, { needsWater: true });
if (target) {
  api.moveTo(robot, target.x, target.y);
  api.water(robot, target.x, target.y);
} else {
  api.idle(robot);
}"></textarea>
        <div id="code-error-msg" class="code-error"></div>
        <div style="display:flex;gap:6px;margin-top:6px">
          <button class="game-btn primary" onclick="saveRobotCode()">üíæ Save Code</button>
          <button class="game-btn" onclick="clearRobotCode()">üóë Clear</button>
          <button class="game-btn danger" onclick="deleteSelectedRobot()">üíÄ Remove Robot</button>
        </div>
      </div>
    </div>
  </div>
</div>
</div>

<!-- DOCS MODAL -->
<div class="modal-overlay hidden" id="modal-docs">
<div class="modal" style="width:660px;max-height:85vh">
  <div class="modal-header">
    <span class="modal-title">üìñ ROBO FARM GUIDE</span>
    <span class="modal-close" onclick="closeModal('docs')">‚úï</span>
  </div>
  <div class="modal-body docs-body">
    <div class="modal-tabs">
      <button class="tab-btn active" onclick="switchTab('docs','basics')">Basics</button>
      <button class="tab-btn" onclick="switchTab('docs','farming')">Farming</button>
      <button class="tab-btn" onclick="switchTab('docs','robots')">Robots</button>
      <button class="tab-btn" onclick="switchTab('docs','coding')">Robot Coding</button>
      <button class="tab-btn" onclick="switchTab('docs','tips')">Tips</button>
    </div>
    <div id="docs-tab-basics" class="tab-content active">
      <h2>üåæ WELCOME TO ROBO FARM!</h2>
      <p>Hey there, future farming tycoon! You've landed on a beautiful piece of procedurally-generated wilderness. Your mission: turn this wild land into a thriving automated farm empire. Part Stardew Valley coziness, part Factorio efficiency ‚Äî it's farming, but with <strong>robots</strong>.</p>
      <h3>CONTROLS</h3>
      <p><span class="key">W A S D</span> or <span class="key">‚Üë ‚Üì ‚Üê ‚Üí</span> ‚Äî Move your farmer around the world</p>
      <p><span class="key">1-9</span> ‚Äî Select tools from your hotbar</p>
      <p><span class="key">Left Click</span> ‚Äî Use the selected tool on a tile</p>
      <p><span class="key">E</span> ‚Äî Open Shop</p>
      <p><span class="key">R</span> ‚Äî Open Robot Manager</p>
      <p><span class="key">F</span> ‚Äî Open this guide!</p>
      <p><span class="key">Scroll Wheel</span> ‚Äî Zoom in/out</p>
      <p><span class="key">Space</span> ‚Äî Use tool on tile under player</p>
      <p><span class="key">ESC</span> ‚Äî Cancel action / close menus</p>
      <div class="tip">üí° <strong>Pro tip:</strong> You don't have to click exactly on tiles ‚Äî any click near a tile in the game world will use your current tool on the nearest valid target!</div>
      <h3>THE GOAL</h3>
      <p>There's no real "end" ‚Äî just an endlessly satisfying farming loop. <strong>Plant crops, grow them, harvest them, sell them, buy more robots</strong>. Watch your little mechanical farm hands automate everything while you sip virtual coffee and design even better robot programs.</p>
    </div>
    <div id="docs-tab-farming" class="tab-content">
      <h2>üå± FARMING GUIDE</h2>
      <h3>THE BASICS</h3>
      <p>Farming happens in three steps: <strong>Till ‚Üí Plant ‚Üí Water ‚Üí Harvest</strong>. Each crop has its own growth timer and water requirements.</p>
      <p><strong>Step 1 ‚Äî Till the Soil:</strong> Select the Hoe tool (<span class="key">2</span>) and click any grass tile in your farm zone. The ground will turn into rich, dark soil ready for planting!</p>
      <p><strong>Step 2 ‚Äî Plant a Seed:</strong> Select any seed from your hotbar (<span class="key">4</span>‚Äì<span class="key">8</span>) and click a tilled tile. Your farmer will press the seed into the ground. Make sure you actually have seeds ‚Äî buy them at the Shop!</p>
      <p><strong>Step 3 ‚Äî Water It:</strong> Select the Watering Can (<span class="key">3</span>) and click your planted tile. You'll see the soil darken. Each crop needs watering multiple times throughout its growth cycle.</p>
      <p><strong>Step 4 ‚Äî Harvest:</strong> When a crop reaches full size (it'll look bigger and more vibrant!), use the Hand tool (<span class="key">1</span>) and click it. The crops pop into your inventory!</p>
      <div class="tip">üí° <strong>Rain!</strong> On rainy days, ALL crops get watered automatically. Watch for the weather forecast in the top bar ‚Äî plan ahead!</div>
      <h3>CROP GUIDE</h3>
      <p><strong>üåæ Wheat</strong> ‚Äî The starter crop. Fast-growing, low maintenance. Great for beginners and bulk production.</p>
      <p><strong>ü•ï Carrot</strong> ‚Äî Mid-tier. Decent value, moderate water needs. Good middle-ground crop.</p>
      <p><strong>üåΩ Corn</strong> ‚Äî Slow but profitable! Takes time but yields 4 per harvest. Worth the patience.</p>
      <p><strong>üåª Sunflower</strong> ‚Äî Moderate everything. Also looks gorgeous. Sometimes prices spike for these!</p>
      <p><strong>ü•î Potato</strong> ‚Äî Your bulk crop. Yields 5 per harvest! Great for robots since they water less.</p>
      <p><strong>üçÖ Tomato</strong> ‚Äî The high roller. Most expensive crop, most demanding. Perfect for dedicated robot teams.</p>
      <h3>SEASONS</h3>
      <p>The year has four seasons: Spring, Summer, Fall, and Winter. <strong>In Winter, crops don't grow</strong> ‚Äî so harvest everything before the snow comes! Robots still work in winter, so you can use that time to prepare your farm.</p>
    </div>
    <div id="docs-tab-robots" class="tab-content">
      <h2>ü§ñ ROBOT GUIDE</h2>
      <p>Robots are your best friends. Once you automate your farm, you can focus on expansion, design, and making your robot programs smarter. Buy your first robot at the Shop for 200 coins!</p>
      <h3>PLACING ROBOTS</h3>
      <p>Select the Robot tool (<span class="key">9</span>) and click any walkable tile to place a robot there. The robot will stand by, waiting for instructions. You can have up to 12 robots at once!</p>
      <h3>ASSIGNING TASKS (NO CODING)</h3>
      <p>Select the <strong>Hand tool</strong> (<span class="key">1</span>) and click any robot. The Robot Manager panel will open for that robot. From there:</p>
      <p>1. Choose a <strong>Behavior</strong> from the dropdown (like "Full Cycle" or "Smart Waterer")</p>
      <p>2. Set an <strong>Assigned Crop</strong> (what seeds it should plant)</p>
      <p>3. Click <strong>Set Area</strong> to define the zone it works in ‚Äî then click the center of your field</p>
      <p>4. Done! The robot will get to work immediately.</p>
      <div class="tip">üí° <strong>No coding required!</strong> The built-in behaviors handle everything. "Full Cycle" is the most powerful ‚Äî it harvests, waters, and plants automatically!</div>
      <h3>ROBOT BATTERY</h3>
      <p>Robots have batteries. When they run low, they'll return to their starting position to charge. You can see battery levels in the Robot Manager. Upgrade batteries in a future update for longer work cycles!</p>
      <h3>ROBOT INVENTORY</h3>
      <p>Robots can carry up to 20 items. When they fill up with harvested crops, they'll drop them at your barn (the starting position). The crops automatically go to your inventory!</p>
    </div>
    <div id="docs-tab-coding" class="tab-content">
      <h2>‚ö° ROBOT PROGRAMMING</h2>
      <p>This is where Robo Farm gets <em>really</em> fun. Every robot can run custom JavaScript code as its "brain". You can write behaviors in two places:</p>
      <h3>IN-GAME CODE EDITOR</h3>
      <p>Click a robot ‚Üí Robot Manager ‚Üí scroll down to the <strong>Custom JS Code</strong> section. Write your behavior code there. It's like writing the body of a <code>function(robot, api)</code>.</p>
      <h3>IN SETTINGS.JS (RECOMMENDED)</h3>
      <p>Open <code>settings.js</code> in any text editor and find the <code>customBehaviors</code> section. Add your behavior there and it'll show up in the robot's behavior dropdown!</p>
      <h3>THE ROBOT API</h3>
      <p><code>api.pos(robot)</code> ‚Äî Get current tile position <code>&#123;x, y&#125;</code></p>
      <p><code>api.findCrop(robot, filter)</code> ‚Äî Find nearest crop. Filter: <code>&#123; ready, needsWater, type, maxDist, cx, cy &#125;</code></p>
      <p><code>api.findTile(robot, filter)</code> ‚Äî Find nearest tile. Filter: <code>&#123; tileType, empty, maxDist &#125;</code></p>
      <p><code>api.moveTo(robot, x, y)</code> ‚Äî Path toward tile</p>
      <p><code>api.water(robot, x, y)</code> ‚Äî Water a crop tile</p>
      <p><code>api.harvest(robot, x, y)</code> ‚Äî Harvest a ready crop</p>
      <p><code>api.plant(robot, x, y, cropType)</code> ‚Äî Plant a seed</p>
      <p><code>api.till(robot, x, y)</code> ‚Äî Till a grass tile</p>
      <p><code>api.idle(robot)</code> ‚Äî Do nothing this tick</p>
      <p><code>api.mem(robot, key, value?)</code> ‚Äî Get/set persistent memory between ticks</p>
      <p><code>api.inventory(robot)</code> ‚Äî Returns <code>&#123; seeds: &#123;...&#125;, crops: &#123;...&#125; &#125;</code></p>
      <p><code>api.nearby(robot, radius)</code> ‚Äî Array of nearby tile objects</p>
      <div class="tip">üí° <strong>Tip:</strong> Use <code>robot.assignedCrop</code> to get the crop set in the panel, and <code>robot.workArea</code> for <code>&#123;x, y, radius&#125;</code>. Great for making configurable behaviors!</div>
    </div>
    <div id="docs-tab-tips" class="tab-content">
      <h2>‚ú® TIPS & TRICKS</h2>
      <h3>EARLY GAME</h3>
      <p>Start by tilling a 5x5 plot and planting all your starter wheat. Water it twice and you'll have your first harvest in about a day. Sell those crops and immediately buy your first robot!</p>
      <p>A single "Full Cycle" robot assigned to your wheat field will keep it running while you expand your farm. Use your own time for new development!</p>
      <h3>MID GAME</h3>
      <p>Three robots is the sweet spot for early automation: one waterer, one planter, one harvester. Or use three "Full Cycle" bots for maximum efficiency.</p>
      <p>Don't sleep on <strong>Potatoes</strong> ‚Äî they yield 5 items per harvest and only need watering twice. Excellent robot food!</p>
      <h3>LATE GAME</h3>
      <p>With 8+ robots, you can run multiple dedicated crop zones. Try a dedicated Tomato operation ‚Äî one robot per 3x3 patch, all running Zone Farmer. The income is ridiculous!</p>
      <p>Write custom robot behaviors that adapt to market prices. Check <code>api.mem()</code> examples in the settings.js file!</p>
      <h3>WORLD EXPLORATION</h3>
      <p>Don't stay in your farm zone! The world has forests, rivers, ponds, and wildflower meadows. There's nothing to collect out there (yet!), but it's beautiful. Take a walk sometimes. üå≤</p>
      <div class="tip">üí° <strong>Secret:</strong> Change the <code>seed</code> value in settings.js to get a completely different world layout. Each seed generates unique river paths, forest positions, and terrain features!</div>
    </div>
  </div>
</div>
</div>

<script>
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * ROBO FARM ‚Äî MAIN GAME
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

const S = window.GAME_SETTINGS;
const TILE = S.world.tileSize;
const WW = S.world.width;
const WH = S.world.height;

/* ‚îÄ‚îÄ‚îÄ SEEDED RNG ‚îÄ‚îÄ‚îÄ */
function mkRng(seed) {
  let s = seed >>> 0;
  return () => { s ^= s << 13; s ^= s >> 17; s ^= s << 5; return (s >>> 0) / 4294967296; };
}
const worldRng = mkRng(S.world.seed);

/* ‚îÄ‚îÄ‚îÄ HASH HELPERS ‚îÄ‚îÄ‚îÄ */
function hash2(x, y) { let h = (x * 374761393 + y * 668265263) >>> 0; h = ((h ^ (h >> 13)) * 1274126177) >>> 0; return (h >>> 0) / 4294967296; }
function tileRnd(x, y, i) { return hash2(x * 7 + i, y * 13 + i * 3); }

/* ‚îÄ‚îÄ‚îÄ VALUE NOISE ‚îÄ‚îÄ‚îÄ */
function smoothstep(t) { return t * t * (3 - 2 * t); }
function lerp(a, b, t) { return a + (b - a) * t; }
function valueNoise(x, y, scale) {
  const ix = Math.floor(x / scale), iy = Math.floor(y / scale);
  const fx = (x / scale) - ix, fy = (y / scale) - iy;
  const tx = smoothstep(fx), ty = smoothstep(fy);
  return lerp(lerp(hash2(ix, iy), hash2(ix + 1, iy), tx), lerp(hash2(ix, iy + 1), hash2(ix + 1, iy + 1), tx), ty);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * WORLD GENERATION
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let world = [];

function createTile(type) {
  return { type, crop: null, watered: false, variant: 0, animOffset: 0 };
}

function inBounds(x, y) { return x >= 0 && y >= 0 && x < WW && y < WH; }

function generateWorld() {
  world = [];
  for (let y = 0; y < WH; y++) { world[y] = []; for (let x = 0; x < WW; x++) world[y][x] = createTile('grass'); }

  // Tree noise layer
  for (let y = 0; y < WH; y++) for (let x = 0; x < WW; x++) {
    const n = valueNoise(x, y, 6);
    const edgeDist = Math.min(x, y, WW - 1 - x, WH - 1 - y);
    const edgeBias = edgeDist < 5 ? (5 - edgeDist) / 5 : 0;
    if (n + edgeBias * 0.4 > (1 - S.world.treeFrequency)) {
      world[y][x].type = 'tree'; world[y][x].variant = Math.floor(tileRnd(x, y, 0) * 3);
    }
  }

  // Rocks
  for (let y = 1; y < WH - 1; y++) for (let x = 1; x < WW - 1; x++) {
    if (world[y][x].type === 'grass' && tileRnd(x, y, 1) < S.world.rockFrequency) world[y][x].type = 'rock';
  }

  // Wildflowers
  for (let y = 1; y < WH - 1; y++) for (let x = 1; x < WW - 1; x++) {
    if (world[y][x].type === 'grass' && tileRnd(x, y, 2) < S.world.flowerFrequency) {
      world[y][x].type = 'flower'; world[y][x].variant = Math.floor(tileRnd(x, y, 3) * 5);
    }
  }

  // Rivers
  const riverRng = mkRng(S.world.seed + 100);
  for (let r = 0; r < S.world.riverCount; r++) {
    const startEdge = Math.floor(riverRng() * 4);
    let rx, ry, dirX, dirY;
    if (startEdge === 0) { rx = Math.floor(riverRng() * WW); ry = 0; dirX = 0; dirY = 1; }
    else if (startEdge === 1) { rx = WW - 1; ry = Math.floor(riverRng() * WH); dirX = -1; dirY = 0; }
    else if (startEdge === 2) { rx = Math.floor(riverRng() * WW); ry = WH - 1; dirX = 0; dirY = -1; }
    else { rx = 0; ry = Math.floor(riverRng() * WH); dirX = 1; dirY = 0; }

    for (let step = 0; step < WW + WH; step++) {
      if (!inBounds(rx, ry)) break;
      for (let w = -1; w <= 1; w++) {
        const wx = rx + (dirY !== 0 ? w : 0), wy = ry + (dirX !== 0 ? w : 0);
        if (inBounds(wx, wy)) world[wy][wx].type = 'water';
      }
      const turn = riverRng();
      if (turn < 0.3) { rx += dirX; if (dirX === 0) rx += (riverRng() < 0.5 ? -1 : 1); else ry += (riverRng() < 0.5 ? -1 : 1); }
      else { rx += dirX; ry += dirY; }
      if (riverRng() < 0.15) { const tmp = dirX; dirX = dirY * (riverRng() < 0.5 ? 1 : -1); dirY = tmp * (riverRng() < 0.5 ? 1 : -1); }
    }
  }

  // Ponds
  const pondRng = mkRng(S.world.seed + 200);
  for (let p = 0; p < S.world.pondCount; p++) {
    const px = 5 + Math.floor(pondRng() * (WW - 10));
    const py = 5 + Math.floor(pondRng() * (WH - 10));
    const size = 2 + Math.floor(pondRng() * 4);
    for (let dy = -size; dy <= size; dy++) for (let dx = -size; dx <= size; dx++) {
      if (dx * dx + dy * dy <= size * size * (0.6 + pondRng() * 0.4) && inBounds(px + dx, py + dy))
        world[py + dy][px + dx].type = 'water';
    }
  }

  // Clear farm zone
  const fz = S.world;
  for (let y = fz.farmZoneY; y < fz.farmZoneY + fz.farmZoneH; y++)
    for (let x = fz.farmZoneX; x < fz.farmZoneX + fz.farmZoneW; x++)
      if (inBounds(x, y)) world[y][x] = createTile('grass');

  // Assign anim offsets
  for (let y = 0; y < WH; y++) for (let x = 0; x < WW; x++)
    world[y][x].animOffset = tileRnd(x, y, 9) * Math.PI * 2;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * GAME STATE
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let coins = S.player.startCoins;
let day = 1, tick = 0, season = 0;
let isRaining = false, rainDay = false;
const SEASONS = S.time.seasons;
const TPDAY = S.time.ticksPerDay;

let inventory = { seeds: {}, crops: {} };
// Init seeds
for (const [k, v] of Object.entries(S.player.startSeeds)) inventory.seeds[k] = v;

let currentTool = 'hand';
let selectedRobotId = null;
let assigningWorkArea = false;

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PLAYER
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const player = {
  tileX: S.player.startX, tileY: S.player.startY,
  px: S.player.startX * TILE, py: S.player.startY * TILE,
  facingX: 0, facingY: 1, moving: false, frame: 0, frameTimer: 0,
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * CAMERA
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const camera = { x: 0, y: 0, tx: 0, ty: 0, zoom: S.display.zoomLevel };

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * INPUT
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const keys = {};
let mouseWorld = { x: 0, y: 0 };
let mouseScreen = { x: 0, y: 0 };

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Digit1') selectTool('hand');
  else if (e.code === 'Digit2') selectTool('hoe');
  else if (e.code === 'Digit3') selectTool('water');
  else if (e.code === 'Digit4') selectTool('wheat');
  else if (e.code === 'Digit5') selectTool('carrot');
  else if (e.code === 'Digit6') selectTool('corn');
  else if (e.code === 'Digit7') selectTool('sunflower');
  else if (e.code === 'Digit8') selectTool('potato');
  else if (e.code === 'Digit9') selectTool('robot_place');
  else if (e.code === 'KeyE') openModal('shop');
  else if (e.code === 'KeyR') openModal('robots');
  else if (e.code === 'KeyF') openModal('docs');
  else if (e.code === 'Escape') { closeAllModals(); cancelAssign(); }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

const canvas = document.getElementById('game');
const cursorCanvas = document.getElementById('cursor-canvas');
const cc = cursorCanvas.getContext('2d');

canvas.addEventListener('mousemove', e => {
  mouseScreen = { x: e.clientX, y: e.clientY };
  const wx = (e.clientX - camera.x) / camera.zoom;
  const wy = (e.clientY - camera.y) / camera.zoom;
  mouseWorld = { x: wx, y: wy };
  updateCursorCanvas();
});

canvas.addEventListener('click', e => {
  const tx = Math.floor(mouseWorld.x / TILE);
  const ty = Math.floor(mouseWorld.y / TILE);
  handleTileClick(tx, ty, e);
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  camera.zoom = Math.max(0.5, Math.min(3.0, camera.zoom - e.deltaY * 0.001));
}, { passive: false });

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * BFS PATHFINDING
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function isWalkable(x, y) {
  if (!inBounds(x, y)) return false;
  const t = world[y][x].type;
  return t !== 'tree' && t !== 'water' && t !== 'rock';
}

function findPath(sx, sy, gx, gy) {
  if (sx === gx && sy === gy) return [];
  const queue = [{ x: sx, y: sy }];
  const visited = new Map();
  visited.set(`${sx},${sy}`, null);
  const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
  let safety = 0;
  while (queue.length > 0 && safety++ < 2000) {
    const cur = queue.shift();
    if (cur.x === gx && cur.y === gy) {
      const path = [];
      let k = `${gx},${gy}`;
      while (k !== null) {
        const [px, py] = k.split(',').map(Number);
        path.unshift({ x: px, y: py });
        k = visited.get(k);
      }
      return path.slice(1);
    }
    for (const [dx, dy] of dirs) {
      const nx = cur.x + dx, ny = cur.y + dy;
      const key = `${nx},${ny}`;
      if (!visited.has(key) && (isWalkable(nx, ny) || (nx === gx && ny === gy))) {
        visited.set(key, `${cur.x},${cur.y}`);
        queue.push({ x: nx, y: ny });
      }
    }
  }
  return null;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * ROBOTS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let robots = [];
let nextRobotId = 1;

class Robot {
  constructor(tx, ty) {
    this.id = nextRobotId++;
    this.name = `Bot-${this.id}`;
    this.tileX = tx; this.tileY = ty;
    this.px = tx * TILE; this.py = ty * TILE;
    this.homeTileX = tx; this.homeTileY = ty;
    this.battery = S.robots.batteryMax;
    this.path = [];
    this.actionTimer = 0;
    this.workTimer = 0;
    this.state = 'idle';
    this.behavior = S.robots.defaultBehavior;
    this.assignedCrop = 'wheat';
    this.workArea = null;
    this.inventory = { seeds: Object.assign({}, S.player.startSeeds), crops: {} };
    this.inventory.seeds = {};
    this.memory = {};
    this.customCode = '';
    this.compiledCode = null;
    this.codeError = '';
    this.facingX = 0; this.facingY = 1;
    this.frame = 0; this.frameTimer = 0;
  }
}

/* ‚îÄ‚îÄ‚îÄ ROBOT API ‚îÄ‚îÄ‚îÄ */
const robotAPI = {
  pos: (r) => ({ x: r.tileX, y: r.tileY }),

  findCrop: (r, f = {}) => {
    const cx = f.cx ?? r.tileX, cy = f.cy ?? r.tileY, max = f.maxDist ?? 12;
    let best = null, bd = Infinity;
    for (let dy = -max; dy <= max; dy++) for (let dx = -max; dx <= max; dx++) {
      const tx = cx + dx, ty = cy + dy;
      if (!inBounds(tx, ty)) continue;
      const tile = world[ty][tx];
      if (!tile.crop) continue;
      const cfg = S.crops[tile.crop.type];
      if (f.type && tile.crop.type !== f.type) continue;
      if (f.ready && tile.crop.stage < cfg.stages - 1) continue;
      if (f.needsWater) { if (tile.crop.watered || tile.crop.waterCount >= cfg.waterNeeded) continue; }
      const d = Math.abs(dx) + Math.abs(dy);
      if (d < bd) { bd = d; best = { x: tx, y: ty, crop: tile.crop }; }
    }
    return best;
  },

  findTile: (r, f = {}) => {
    const cx = f.cx ?? r.tileX, cy = f.cy ?? r.tileY, max = f.maxDist ?? 12;
    let best = null, bd = Infinity;
    for (let dy = -max; dy <= max; dy++) for (let dx = -max; dx <= max; dx++) {
      const tx = cx + dx, ty = cy + dy;
      if (!inBounds(tx, ty)) continue;
      const tile = world[ty][tx];
      if (f.tileType && tile.type !== f.tileType) continue;
      if (f.empty && tile.crop) continue;
      const d = Math.abs(dx) + Math.abs(dy);
      if (d < bd) { bd = d; best = { x: tx, y: ty, tile }; }
    }
    return best;
  },

  moveTo: (r, x, y) => {
    if (r.tileX === x && r.tileY === y) return;
    if (!r._targetX || r._targetX !== x || r._targetY !== y) {
      r._targetX = x; r._targetY = y;
      r.path = findPath(r.tileX, r.tileY, x, y) || [];
    }
  },

  water: (r, x, y) => {
    if (Math.abs(r.tileX - x) > 1 || Math.abs(r.tileY - y) > 1) { robotAPI.moveTo(r, x, y); return false; }
    if (!inBounds(x, y) || !world[y][x].crop) return false;
    const crop = world[y][x].crop;
    if (crop.watered || crop.waterCount >= S.crops[crop.type].waterNeeded) return false;
    r.state = 'working'; r.actionTimer = 20;
    r._pendingAction = { type: 'water', x, y };
    return true;
  },

  harvest: (r, x, y) => {
    if (Math.abs(r.tileX - x) > 1 || Math.abs(r.tileY - y) > 1) { robotAPI.moveTo(r, x, y); return false; }
    if (!inBounds(x, y) || !world[y][x].crop) return false;
    const crop = world[y][x].crop;
    if (crop.stage < S.crops[crop.type].stages - 1) return false;
    r.state = 'working'; r.actionTimer = 20;
    r._pendingAction = { type: 'harvest', x, y };
    return true;
  },

  plant: (r, x, y, type) => {
    if (Math.abs(r.tileX - x) > 1 || Math.abs(r.tileY - y) > 1) { robotAPI.moveTo(r, x, y); return false; }
    if (!inBounds(x, y) || world[y][x].type !== 'tilled' || world[y][x].crop) return false;
    if (!r.inventory.seeds[type] || r.inventory.seeds[type] <= 0) {
      // Pull seeds from player if possible
      if (inventory.seeds[type] > 0) {
        const take = Math.min(10, inventory.seeds[type]);
        inventory.seeds[type] -= take;
        r.inventory.seeds[type] = (r.inventory.seeds[type] || 0) + take;
        updateUI();
      } else return false;
    }
    r.state = 'working'; r.actionTimer = 20;
    r._pendingAction = { type: 'plant', x, y, cropType: type };
    return true;
  },

  till: (r, x, y) => {
    if (Math.abs(r.tileX - x) > 1 || Math.abs(r.tileY - y) > 1) { robotAPI.moveTo(r, x, y); return false; }
    if (!inBounds(x, y) || world[y][x].type !== 'grass') return false;
    r.state = 'working'; r.actionTimer = 25;
    r._pendingAction = { type: 'till', x, y };
    return true;
  },

  idle: (r) => { r.state = 'idle'; r.path = []; r._pendingAction = null; },

  mem: (r, k, v) => { if (v !== undefined) r.memory[k] = v; return r.memory[k]; },

  inventory: (r) => r.inventory,

  nearby: (r, radius) => {
    const res = [];
    for (let dy = -radius; dy <= radius; dy++) for (let dx = -radius; dx <= radius; dx++) {
      const tx = r.tileX + dx, ty = r.tileY + dy;
      if (inBounds(tx, ty)) res.push({ x: tx, y: ty, ...world[ty][tx] });
    }
    return res;
  },

  distanceTo: (r, x, y) => Math.abs(r.tileX - x) + Math.abs(r.tileY - y),
};

/* ‚îÄ‚îÄ‚îÄ BUILT-IN BEHAVIORS ‚îÄ‚îÄ‚îÄ */
const builtinBehaviors = {
  'idle': (r, api) => api.idle(r),

  'water_area': (r, api) => {
    const t = api.findCrop(r, { needsWater: true, maxDist: r.workArea?.radius || 10, cx: r.workArea?.x, cy: r.workArea?.y });
    if (t) { api.moveTo(r, t.x, t.y); api.water(r, t.x, t.y); } else api.idle(r);
  },

  'harvest': (r, api) => {
    const t = api.findCrop(r, { ready: true, maxDist: r.workArea?.radius || 10, cx: r.workArea?.x, cy: r.workArea?.y });
    if (t) { api.moveTo(r, t.x, t.y); api.harvest(r, t.x, t.y); } else api.idle(r);
  },

  'full_cycle': (r, api) => {
    const max = r.workArea?.radius || 12, cx = r.workArea?.x, cy = r.workArea?.y;
    const ready = api.findCrop(r, { ready: true, maxDist: max, cx, cy });
    if (ready) { api.moveTo(r, ready.x, ready.y); api.harvest(r, ready.x, ready.y); return; }
    const thirsty = api.findCrop(r, { needsWater: true, maxDist: max, cx, cy });
    if (thirsty) { api.moveTo(r, thirsty.x, thirsty.y); api.water(r, thirsty.x, thirsty.y); return; }
    const crop = r.assignedCrop || 'wheat';
    if ((r.inventory.seeds[crop] || 0) > 0 || (inventory.seeds[crop] || 0) > 0) {
      const empty = api.findTile(r, { tileType: 'tilled', empty: true, maxDist: max, cx, cy });
      if (empty) { api.moveTo(r, empty.x, empty.y); api.plant(r, empty.x, empty.y, crop); return; }
    }
    api.idle(r);
  },
};

/* ‚îÄ‚îÄ‚îÄ ALL BEHAVIORS (builtin + custom from settings.js) ‚îÄ‚îÄ‚îÄ */
function getAllBehaviors() {
  return { ...builtinBehaviors, ...(S.customBehaviors || {}) };
}

function runRobotBehavior(robot) {
  robot.workTimer++;
  if (robot.workTimer < S.robots.workDelay) return;
  robot.workTimer = 0;

  if (robot.battery <= 0) {
    robotAPI.moveTo(robot, robot.homeTileX, robot.homeTileY);
    return;
  }

  if (robot.compiledCode) {
    try { robot.compiledCode(robot, robotAPI); robot.codeError = ''; }
    catch (e) { robot.codeError = e.message; robotAPI.idle(robot); }
    return;
  }

  const behaviors = getAllBehaviors();
  const fn = behaviors[robot.behavior] || behaviors['idle'];
  try { fn(robot, robotAPI); } catch(e) { robotAPI.idle(robot); }
}

function updateRobots() {
  for (const robot of robots) {
    // Handle pending action completion
    if (robot.actionTimer > 0) {
      robot.actionTimer--;
      if (robot.actionTimer === 0 && robot._pendingAction) {
        const a = robot._pendingAction;
        robot._pendingAction = null;
        executeRobotAction(robot, a);
      }
      continue;
    }

    // Battery
    if (robot.state === 'working') robot.battery = Math.max(0, robot.battery - S.robots.batteryDrain);
    if (robot.tileX === robot.homeTileX && robot.tileY === robot.homeTileY && robot.battery < S.robots.batteryMax) {
      robot.battery = Math.min(S.robots.batteryMax, robot.battery + S.robots.chargeRate / 60);
    }

    // Drop crops at home
    if (robot.tileX === robot.homeTileX && robot.tileY === robot.homeTileY) {
      for (const [type, qty] of Object.entries(robot.inventory.crops)) {
        if (qty > 0) {
          inventory.crops[type] = (inventory.crops[type] || 0) + qty;
          robot.inventory.crops[type] = 0;
          notify(`ü§ñ ${robot.name} delivered ${qty}x ${S.crops[type].emoji} ${type}!`);
          updateUI();
        }
      }
    }

    // Follow path
    if (robot.path && robot.path.length > 0) {
      const next = robot.path[0];
      const speed = S.robots.speed * TILE / 60;
      const dx = next.x * TILE - robot.px, dy = next.y * TILE - robot.py;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < speed + 1) {
        robot.px = next.x * TILE; robot.py = next.y * TILE;
        robot.tileX = next.x; robot.tileY = next.y;
        robot.path.shift();
        robot.battery = Math.max(0, robot.battery - S.robots.batteryDrain * 0.3);
      } else {
        robot.px += (dx / dist) * speed;
        robot.py += (dy / dist) * speed;
        robot.facingX = Math.sign(dx); robot.facingY = Math.sign(dy);
      }
      robot.frameTimer++;
      if (robot.frameTimer > 10) { robot.frame = (robot.frame + 1) % 4; robot.frameTimer = 0; }
      robot.state = 'moving';
    } else {
      robot.state = robot.battery <= 10 ? 'charging' : 'idle';
      runRobotBehavior(robot);
    }
  }
}

function executeRobotAction(robot, action) {
  if (!inBounds(action.x, action.y)) return;
  const tile = world[action.y][action.x];

  if (action.type === 'water' && tile.crop) {
    const cfg = S.crops[tile.crop.type];
    if (!tile.crop.watered && tile.crop.waterCount < cfg.waterNeeded) {
      tile.crop.watered = true;
      spawnParticles(action.x * TILE + TILE/2, action.y * TILE, 'water', 6);
    }
  } else if (action.type === 'harvest' && tile.crop) {
    const cfg = S.crops[tile.crop.type];
    if (tile.crop.stage >= cfg.stages - 1) {
      const total = cfg.yield;
      robot.inventory.crops[tile.crop.type] = (robot.inventory.crops[tile.crop.type] || 0) + total;
      spawnParticles(action.x * TILE + TILE/2, action.y * TILE, 'harvest', 10);
      tile.crop = null;
    }
  } else if (action.type === 'plant') {
    if (tile.type === 'tilled' && !tile.crop) {
      const seeds = robot.inventory.seeds;
      const type = action.cropType;
      if ((seeds[type] || 0) > 0) {
        seeds[type]--;
        tile.crop = { type, stage: 0, growTimer: 0, waterCount: 0, watered: false };
      }
    }
  } else if (action.type === 'till' && tile.type === 'grass') {
    tile.type = 'tilled';
    spawnParticles(action.x * TILE + TILE/2, action.y * TILE, 'dirt', 5);
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * CROP SYSTEM
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let cropTick = 0;

function updateCrops() {
  cropTick++;
  if (cropTick % 30 !== 0) return;

  const season_name = SEASONS[season % SEASONS.length];
  if (season_name === 'Winter' && S.time.winterEnabled) return;

  for (let y = 0; y < WH; y++) for (let x = 0; x < WW; x++) {
    const tile = world[y][x];
    if (!tile.crop) continue;
    const crop = tile.crop;
    const cfg = S.crops[crop.type];
    if (!cfg) continue;

    if (crop.watered || rainDay) {
      crop.growTimer += 30;
      if (crop.watered) { crop.waterCount++; crop.watered = false; }
    }

    const stageTime = cfg.growTime / cfg.stages;
    const newStage = Math.min(cfg.stages - 1, Math.floor(crop.growTimer / stageTime));
    if (newStage > crop.stage) {
      crop.stage = newStage;
      if (crop.stage >= cfg.stages - 1) spawnParticles(x * TILE + TILE/2, y * TILE, 'grow', 8);
    }
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PARTICLES
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let particles = [];
const MAX_PARTICLES = S.display.particleCount === 'low' ? 50 : S.display.particleCount === 'medium' ? 150 : 300;

function spawnParticles(px, py, type, count) {
  if (particles.length > MAX_PARTICLES) return;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 2.5;
    let color = '#ffffff';
    if (type === 'water') color = ['#4fc3f7','#29b6f6','#81d4fa'][i%3];
    else if (type === 'harvest') color = ['#f5c842','#a5d86e','#ff9944'][i%3];
    else if (type === 'dirt') color = ['#7d5a2a','#5c3d18','#9b7a45'][i%3];
    else if (type === 'grow') color = ['#66bb6a','#a5d86e','#fff176'][i%3];
    particles.push({ x: px, y: py, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - 1, life: 1, color, size: 2 + Math.random() * 3 });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.08; p.life -= 0.03;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * TILE CLICK HANDLER
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function handleTileClick(tx, ty, e) {
  if (!inBounds(tx, ty)) return;

  // Work area assignment
  if (assigningWorkArea && selectedRobotId !== null) {
    const bot = robots.find(r => r.id === selectedRobotId);
    if (bot) {
      bot.workArea = { x: tx, y: ty, radius: 8 };
      document.getElementById('robot-area-display').textContent = `(${tx}, ${ty}) r=8`;
      notify(`ü§ñ ${bot.name} work area set to (${tx}, ${ty})`);
    }
    cancelAssign(); return;
  }

  const tile = world[ty][tx];

  if (currentTool === 'hand') {
    // Check if clicking a robot
    const bot = robots.find(r => r.tileX === tx && r.tileY === ty);
    if (bot) { selectedRobotId = bot.id; openModal('robots'); return; }
    // Harvest ready crop
    if (tile.crop) {
      const cfg = S.crops[tile.crop.type];
      if (tile.crop.stage >= cfg.stages - 1) {
        const got = cfg.yield;
        inventory.crops[tile.crop.type] = (inventory.crops[tile.crop.type] || 0) + got;
        spawnParticles(tx * TILE + TILE/2, ty * TILE, 'harvest', 12);
        notify(`${cfg.emoji} Harvested ${got}x ${tile.crop.type}!`);
        tile.crop = null; updateUI();
      } else notify(`üïê Crop not ready yet (${tile.crop.stage + 1}/${cfg.stages})`);
    }
  } else if (currentTool === 'hoe') {
    if (tile.type === 'grass') {
      tile.type = 'tilled';
      spawnParticles(tx * TILE + TILE/2, ty * TILE, 'dirt', 6);
    } else if (tile.type === 'tilled' && !tile.crop) {
      tile.type = 'grass';
    }
  } else if (currentTool === 'water') {
    if (tile.type === 'tilled' && tile.crop && !tile.crop.watered) {
      const cfg = S.crops[tile.crop.type];
      if (tile.crop.waterCount < cfg.waterNeeded) {
        tile.crop.watered = true;
        spawnParticles(tx * TILE + TILE/2, ty * TILE, 'water', 8);
        notify(`üíß Watered ${tile.crop.type} (${tile.crop.waterCount + 1}/${cfg.waterNeeded})`);
      } else notify(`‚úÖ Crop is fully watered!`);
    } else notify(`üíß Nothing to water here!`);
  } else if (currentTool === 'robot_place') {
    if (isWalkable(tx, ty)) {
      if (robots.length >= S.robots.maxRobots) { notify(`‚ö†Ô∏è Max robots reached (${S.robots.maxRobots})`); return; }
      // Use robot from player 'inventory'
      if (!playerHasRobot()) { notify(`ü§ñ Buy a robot at the Shop first!`); return; }
      usePlayerRobot();
      const bot = new Robot(tx, ty);
      robots.push(bot);
      notify(`ü§ñ ${bot.name} deployed!`);
      updateUI();
    }
  } else {
    // Seed tools
    const cropType = currentTool;
    if (S.crops[cropType]) {
      if (!inventory.seeds[cropType] || inventory.seeds[cropType] <= 0) {
        notify(`‚ùå No ${cropType} seeds! Buy some at the Shop.`); return;
      }
      if (tile.type === 'tilled' && !tile.crop) {
        inventory.seeds[cropType]--;
        tile.crop = { type: cropType, stage: 0, growTimer: 0, waterCount: 0, watered: false };
        spawnParticles(tx * TILE + TILE/2, ty * TILE, 'dirt', 4);
        updateUI();
      } else if (tile.type !== 'tilled') notify(`‚õèÔ∏è Till the soil first!`);
    }
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PLAYER ROBOT INVENTORY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let robotsOwned = S.player.startRobots;
function playerHasRobot() { return robotsOwned > 0; }
function usePlayerRobot() { robotsOwned = Math.max(0, robotsOwned - 1); }

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * ECONOMY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let priceMultipliers = {};
function refreshPrices() {
  if (!S.economy.priceFluctuation) { for (const k of Object.keys(S.crops)) priceMultipliers[k] = 1; return; }
  for (const k of Object.keys(S.crops)) priceMultipliers[k] = 1 + (Math.random() - 0.5) * 2 * S.economy.fluctuationAmount;
}
refreshPrices();

function getCropPrice(type) { return Math.round((S.economy.cropPrices[type] || 10) * (priceMultipliers[type] || 1)); }

function buySeeds(type, qty) {
  const cost = (S.economy.seedPrices[type] || 5) * qty;
  if (coins < cost) { notify(`‚ùå Need ${cost} coins!`); return; }
  coins -= cost; inventory.seeds[type] = (inventory.seeds[type] || 0) + qty;
  notify(`‚úÖ Bought ${qty}x ${S.crops[type]?.emoji} ${type} seeds!`);
  updateUI(); buildShop();
}

function buyRobot() {
  const cost = S.economy.robotCost;
  if (coins < cost) { notify(`‚ùå Need ${cost} coins! Sell some crops.`); return; }
  coins -= cost; robotsOwned++;
  notify(`ü§ñ Robot purchased! Use the Robot tool (9) to place it.`);
  updateUI();
  document.getElementById('robot-count-display').textContent = `Owned: ${robotsOwned}`;
}

function sellCrop(type) {
  const qty = inventory.crops[type] || 0;
  if (qty <= 0) { notify(`‚ùå No ${type} to sell!`); return; }
  const bonus = qty >= 10 ? S.economy.bulkBonus : 1;
  const earned = Math.round(getCropPrice(type) * qty * bonus);
  coins += earned; delete inventory.crops[type];
  notify(`üí∞ Sold ${qty}x ${type} for ${earned} coins${bonus > 1 ? ' (bulk bonus!)' : ''}!`);
  updateUI(); buildSellGrid();
}

function sellAll() {
  let total = 0;
  for (const [type, qty] of Object.entries(inventory.crops)) {
    if (qty > 0) {
      const bonus = qty >= 10 ? S.economy.bulkBonus : 1;
      total += Math.round(getCropPrice(type) * qty * bonus);
    }
  }
  if (total === 0) { notify(`‚ùå Nothing to sell!`); return; }
  coins += total; inventory.crops = {};
  notify(`üí∞ Sold everything for ${total} coins!`);
  updateUI(); buildSellGrid();
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * SAVE / LOAD
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function saveGame() {
  const save = { v: 2, coins, day, tick, season, isRaining, rainDay, inventory, robotsOwned,
    nextRobotId, priceMultipliers, robots: robots.map(r => ({
      id: r.id, name: r.name, tileX: r.tileX, tileY: r.tileY, homeTileX: r.homeTileX, homeTileY: r.homeTileY,
      battery: r.battery, behavior: r.behavior, assignedCrop: r.assignedCrop, workArea: r.workArea,
      inventory: r.inventory, memory: r.memory, customCode: r.customCode,
    })),
    world: world.map(row => row.map(t => ({ type: t.type, crop: t.crop ? { ...t.crop } : null, watered: t.watered })))
  };
  try { localStorage.setItem('roboFarm_save', JSON.stringify(save)); notify('üíæ Game saved!'); } catch(e) { notify('‚ùå Save failed!'); }
}

function loadGame() {
  try {
    const raw = localStorage.getItem('roboFarm_save');
    if (!raw) return false;
    const save = JSON.parse(raw);
    if (save.v !== 2) { localStorage.removeItem('roboFarm_save'); return false; }
    coins = save.coins; day = save.day; tick = save.tick; season = save.season;
    isRaining = save.isRaining; rainDay = save.rainDay; inventory = save.inventory;
    robotsOwned = save.robotsOwned; nextRobotId = save.nextRobotId; priceMultipliers = save.priceMultipliers;
    // Restore world
    for (let y = 0; y < WH; y++) for (let x = 0; x < WW; x++) {
      if (save.world[y] && save.world[y][x]) {
        world[y][x].type = save.world[y][x].type;
        world[y][x].crop = save.world[y][x].crop;
        world[y][x].watered = save.world[y][x].watered || false;
      }
    }
    // Restore robots
    robots = [];
    for (const rd of save.robots) {
      const bot = new Robot(rd.tileX, rd.tileY);
      Object.assign(bot, rd);
      bot.px = bot.tileX * TILE; bot.py = bot.tileY * TILE;
      bot.path = []; bot._pendingAction = null; bot.actionTimer = 0; bot.workTimer = 0;
      if (bot.customCode) compileRobotCode(bot);
      robots.push(bot);
    }
    return true;
  } catch(e) { console.warn('Load failed', e); return false; }
}

function compileRobotCode(robot) {
  if (!robot.customCode || robot.customCode.trim() === '') { robot.compiledCode = null; robot.codeError = ''; return; }
  try {
    robot.compiledCode = new Function('robot', 'api', robot.customCode);
    robot.codeError = '';
  } catch(e) { robot.compiledCode = null; robot.codeError = e.message; }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * RENDERING
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const gameCanvas = document.getElementById('game');
const ctx = gameCanvas.getContext('2d');
let W = 0, H = 0;

const GRASS_COLORS = ['#3d7f38','#4a8c44','#44864e','#529448'];
const WATER_COLORS = ['#1a6fa3','#2478b0','#1c7abd'];
const FLOWER_COLORS = ['#ff6b9d','#ff9f43','#ffd32a','#a29bfe','#ff7675'];
const TREE_TRUNK = '#5c3d1a';
const TREE_CANOPY = ['#2d6e25','#356b2a','#3d7a32','#2a6020'];

function resize() {
  W = window.innerWidth; H = window.innerHeight;
  gameCanvas.width = W; gameCanvas.height = H;
  cursorCanvas.width = W; cursorCanvas.height = H;
}

let animTime = 0;

function render() {
  ctx.save();
  ctx.clearRect(0, 0, W, H);

  // Sky
  const dayProgress = tick / TPDAY;
  const skyColor = getSkyColor(dayProgress);
  ctx.fillStyle = skyColor;
  ctx.fillRect(0, 0, W, H);

  // Camera transform
  ctx.setTransform(camera.zoom, 0, 0, camera.zoom, camera.x, camera.y);

  // Viewport culling
  const vx0 = Math.max(0, Math.floor(-camera.x / (TILE * camera.zoom)) - 1);
  const vy0 = Math.max(0, Math.floor(-camera.y / (TILE * camera.zoom)) - 1);
  const vx1 = Math.min(WW - 1, Math.ceil((W - camera.x) / (TILE * camera.zoom)) + 1);
  const vy1 = Math.min(WH - 1, Math.ceil((H - camera.y) / (TILE * camera.zoom)) + 1);

  // Draw tiles
  for (let y = vy0; y <= vy1; y++) {
    for (let x = vx0; x <= vx1; x++) {
      drawTile(x, y);
    }
  }

  // Draw crops
  for (let y = vy0; y <= vy1; y++) {
    for (let x = vx0; x <= vx1; x++) {
      if (world[y][x].crop) drawCrop(x, y);
    }
  }

  // Draw robots
  for (const bot of robots) drawRobot(bot);

  // Draw player
  drawPlayer();

  // Draw particles
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  // Draw robot work areas
  if (S.display.showRobotPath) {
    for (const bot of robots) {
      if (bot.workArea && selectedRobotId === bot.id) {
        ctx.strokeStyle = 'rgba(255,200,50,0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc((bot.workArea.x + 0.5) * TILE, (bot.workArea.y + 0.5) * TILE, bot.workArea.radius * TILE, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      if (bot.path && bot.path.length > 0 && selectedRobotId === bot.id) {
        ctx.strokeStyle = 'rgba(100,200,255,0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(bot.px + TILE/2, bot.py + TILE/2);
        for (const step of bot.path) ctx.lineTo(step.x * TILE + TILE/2, step.y * TILE + TILE/2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }

  // Highlight hovered tile
  const htx = Math.floor(mouseWorld.x / TILE);
  const hty = Math.floor(mouseWorld.y / TILE);
  if (inBounds(htx, hty)) {
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1.5 / camera.zoom;
    ctx.strokeRect(htx * TILE + 0.5, hty * TILE + 0.5, TILE - 1, TILE - 1);
  }

  // Night overlay
  const nightAlpha = getNightAlpha(dayProgress);
  if (nightAlpha > 0) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = `rgba(10, 5, 30, ${nightAlpha})`;
    ctx.fillRect(0, 0, W, H);
    // Stars at night
    if (nightAlpha > 0.3) drawStars(nightAlpha);
  }

  // Rain overlay
  if (rainDay) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    drawRain();
  }

  ctx.restore();
}

function getSkyColor(dp) {
  if (dp < 0.2) return lerpColor('#0d1b3e', '#ff8c42', dp / 0.2);
  if (dp < 0.4) return lerpColor('#ff8c42', '#87ceeb', (dp - 0.2) / 0.2);
  if (dp < 0.7) return '#87ceeb';
  if (dp < 0.85) return lerpColor('#87ceeb', '#ff6b35', (dp - 0.7) / 0.15);
  return lerpColor('#ff6b35', '#0d1b3e', (dp - 0.85) / 0.15);
}

function getNightAlpha(dp) {
  if (dp < 0.1) return lerp(0.7, 0, dp / 0.1);
  if (dp > 0.9) return lerp(0, 0.7, (dp - 0.9) / 0.1);
  return 0;
}

function lerpColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
  const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
  return `rgb(${Math.round(r1+(r2-r1)*t)},${Math.round(g1+(g2-g1)*t)},${Math.round(b1+(b2-b1)*t)})`;
}

function drawStars(alpha) {
  ctx.fillStyle = `rgba(255,255,255,${alpha * 0.6})`;
  for (let i = 0; i < 80; i++) {
    const sx = hash2(i * 7, 1) * W;
    const sy = hash2(i * 3, 2) * H * 0.5;
    const blink = Math.sin(animTime * 0.05 + i) * 0.3 + 0.7;
    ctx.globalAlpha = alpha * blink * 0.7;
    ctx.fillRect(sx, sy, 1.5, 1.5);
  }
  ctx.globalAlpha = 1;
}

function drawRain() {
  ctx.strokeStyle = 'rgba(160,200,255,0.25)';
  ctx.lineWidth = 1;
  const count = 120;
  for (let i = 0; i < count; i++) {
    const rx = ((hash2(i, 1) * W + animTime * 3) % W);
    const ry = ((hash2(i, 2) * H + animTime * 8) % H);
    ctx.beginPath(); ctx.moveTo(rx, ry); ctx.lineTo(rx - 2, ry + 10); ctx.stroke();
  }
}

function drawTile(x, y) {
  const tile = world[y][x];
  const px = x * TILE, py = y * TILE;
  const rnd = tileRnd(x, y, 0);

  if (tile.type === 'grass' || tile.type === 'flower') {
    ctx.fillStyle = GRASS_COLORS[Math.floor(rnd * 4)];
    ctx.fillRect(px, py, TILE, TILE);
    // Grass blades
    ctx.fillStyle = rnd > 0.5 ? '#3a7035' : '#4fa040';
    for (let i = 0; i < 3; i++) {
      const bx = px + tileRnd(x, y, i+1) * TILE, by = py + tileRnd(x, y, i+4) * TILE;
      ctx.fillRect(bx, by, 1, 3);
    }
    if (tile.type === 'flower') {
      const fc = FLOWER_COLORS[tile.variant];
      const fx = px + 4 + rnd * (TILE - 12), fy = py + 5 + tileRnd(x,y,8) * (TILE - 14);
      ctx.fillStyle = '#5a8a3a'; ctx.fillRect(fx + 1, fy - 2, 1, 6);
      ctx.fillStyle = fc; ctx.fillRect(fx, fy - 4, 4, 3);
      ctx.fillRect(fx - 1, fy - 3, 6, 1);
    }
  } else if (tile.type === 'tilled') {
    ctx.fillStyle = '#3c240e'; ctx.fillRect(px, py, TILE, TILE);
    ctx.fillStyle = '#4f3018';
    for (let i = 0; i < TILE; i += 4) { ctx.fillRect(px, py + i, TILE, 2); }
    if (tile.watered || (tile.crop && tile.crop.watered)) {
      ctx.fillStyle = 'rgba(30, 80, 150, 0.25)'; ctx.fillRect(px, py, TILE, TILE);
    }
  } else if (tile.type === 'water') {
    const wv = Math.sin(animTime * 0.05 + tile.animOffset) * 0.15 + 0.85;
    const wi = Math.floor(wv * WATER_COLORS.length) % WATER_COLORS.length;
    ctx.fillStyle = WATER_COLORS[wi]; ctx.fillRect(px, py, TILE, TILE);
    // Shimmer
    ctx.fillStyle = `rgba(255,255,255,${0.1 + Math.sin(animTime * 0.08 + rnd * 6) * 0.06})`;
    ctx.fillRect(px + 4, py + 8, TILE - 10, 2);
    ctx.fillRect(px + 10, py + 18, TILE - 16, 2);
  } else if (tile.type === 'tree') {
    ctx.fillStyle = GRASS_COLORS[0]; ctx.fillRect(px, py, TILE, TILE);
    ctx.fillStyle = TREE_TRUNK; ctx.fillRect(px + TILE/2 - 3, py + TILE/2 + 2, 6, TILE/2);
    ctx.fillStyle = TREE_CANOPY[tile.variant % 4];
    ctx.beginPath(); ctx.arc(px + TILE/2, py + TILE/2, TILE/2 - 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.arc(px + TILE/2 + 2, py + TILE/2 + 2, TILE/2 - 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = TREE_CANOPY[tile.variant % 4];
    ctx.beginPath(); ctx.arc(px + TILE/2, py + TILE/2, TILE/2 - 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.arc(px + TILE/2 - 3, py + TILE/2 - 4, 4, 0, Math.PI * 2); ctx.fill();
  } else if (tile.type === 'rock') {
    ctx.fillStyle = GRASS_COLORS[0]; ctx.fillRect(px, py, TILE, TILE);
    ctx.fillStyle = '#888'; ctx.fillRect(px + 5, py + 8, TILE - 10, TILE - 14);
    ctx.fillStyle = '#aaa'; ctx.fillRect(px + 6, py + 9, 4, 3);
    ctx.fillStyle = '#666'; ctx.fillRect(px + 5, py + 18, TILE - 10, 4);
  }
}

function drawCrop(x, y) {
  const tile = world[y][x];
  const crop = tile.crop;
  const cfg = S.crops[crop.type];
  const px = x * TILE, py = y * TILE;
  const progress = crop.stage / (cfg.stages - 1);
  const h = Math.round(4 + progress * (TILE - 8));
  const w = Math.round(3 + progress * (TILE - 16));
  const cx = px + TILE / 2;
  const bot = py + TILE - 4;
  const wobble = Math.sin(animTime * 0.08 + tile.animOffset) * (2 * progress);

  ctx.fillStyle = '#5a8a3a';
  ctx.fillRect(cx - 1, bot - h, 2, h);

  if (crop.stage >= 1) {
    ctx.fillStyle = cfg.color;
    ctx.fillRect(cx - w/2 + wobble, bot - h, w, Math.round(h * 0.6));
    if (crop.stage >= 2) {
      ctx.fillStyle = '#6aad48';
      ctx.fillRect(cx - 4 + wobble * 0.7, bot - h * 0.5, 8, 4);
    }
    if (crop.stage >= cfg.stages - 1) {
      // Ready glow
      ctx.fillStyle = 'rgba(255,230,50,0.3)';
      ctx.beginPath(); ctx.arc(cx, bot - h / 2, w/2 + 2, 0, Math.PI*2); ctx.fill();
    }
  }

  // Watered indicator
  if (tile.crop.watered) {
    ctx.fillStyle = 'rgba(70,180,255,0.4)';
    ctx.fillRect(px + 1, py + TILE - 4, TILE - 2, 3);
  }
}

function drawPlayer() {
  const px = player.px + 2, py = player.py;
  const leg = (player.frame % 2 === 0 && player.moving) ? 2 : 0;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(px + 2, py + TILE - 6, TILE - 10, 4);

  // Legs
  ctx.fillStyle = '#4a3a8c';
  ctx.fillRect(px + 4, py + TILE - 12, 4, 8 - leg);
  ctx.fillRect(px + TILE - 14, py + TILE - 12, 4, 8 + leg);

  // Body (overalls)
  ctx.fillStyle = '#6a9ae8';
  ctx.fillRect(px + 2, py + TILE - 20, TILE - 10, 10);

  // Arms
  ctx.fillStyle = '#c07848';
  ctx.fillRect(px - 2, py + TILE - 20, 4, 8);
  ctx.fillRect(px + TILE - 8, py + TILE - 20, 4, 8);

  // Head
  ctx.fillStyle = '#d49060';
  ctx.fillRect(px + 4, py + TILE - 28, TILE - 14, 10);

  // Hat
  ctx.fillStyle = '#8b5e2a';
  ctx.fillRect(px + 2, py + TILE - 28, TILE - 10, 3);
  ctx.fillRect(px + 5, py + TILE - 32, TILE - 16, 6);

  // Eyes
  ctx.fillStyle = '#222';
  ctx.fillRect(px + 7, py + TILE - 25, 2, 2);
  ctx.fillRect(px + 13, py + TILE - 25, 2, 2);
}

function drawRobot(bot) {
  const px = bot.px + 2, py = bot.py;
  const selected = bot.id === selectedRobotId;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(px + 2, py + TILE - 4, TILE - 10, 4);

  // Wheels/tracks
  ctx.fillStyle = '#333';
  ctx.fillRect(px + 1, py + TILE - 10, TILE - 8, 5);

  // Body
  ctx.fillStyle = selected ? '#c8d8f0' : '#a8b8c8';
  ctx.fillRect(px + 3, py + TILE - 22, TILE - 12, 14);

  // Panel details
  ctx.fillStyle = '#7a8a98';
  ctx.fillRect(px + 5, py + TILE - 20, 6, 4);
  ctx.fillRect(px + TILE - 18, py + TILE - 20, 6, 4);

  // Head
  ctx.fillStyle = selected ? '#d8e8ff' : '#b8c8d8';
  ctx.fillRect(px + 5, py + TILE - 30, TILE - 16, 10);

  // Eyes (LED)
  const eyeColor = bot.battery > 30 ? (bot.state === 'working' ? '#40ff80' : '#ffcc00') : '#ff4040';
  ctx.fillStyle = eyeColor;
  ctx.fillRect(px + 7, py + TILE - 28, 3, 3);
  ctx.fillRect(px + TILE - 18, py + TILE - 28, 3, 3);
  // Eye glow
  ctx.fillStyle = eyeColor.replace(')', ',0.3)').replace('rgb','rgba');
  ctx.fillRect(px + 6, py + TILE - 29, 5, 5);
  ctx.fillRect(px + TILE - 19, py + TILE - 29, 5, 5);

  // Antenna
  ctx.fillStyle = '#888';
  ctx.fillRect(px + TILE/2 - 5, py + TILE - 34, 2, 6);
  ctx.fillStyle = selected ? '#ffcc00' : '#cc4444';
  ctx.fillRect(px + TILE/2 - 6, py + TILE - 37, 4, 4);

  // Battery bar above robot
  const barW = TILE - 8;
  const bPct = bot.battery / S.robots.batteryMax;
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(px + 1, py - 8, barW, 5);
  ctx.fillStyle = bPct > 0.5 ? '#40cc40' : bPct > 0.2 ? '#ffaa00' : '#ff4040';
  ctx.fillRect(px + 1, py - 8, barW * bPct, 5);

  // Selection highlight
  if (selected) {
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([3, 3]);
    ctx.strokeRect(px, py + TILE - 32, TILE - 6, 32);
    ctx.setLineDash([]);
  }

  // Error indicator
  if (bot.codeError) {
    ctx.fillStyle = '#ff4040';
    ctx.fillRect(px + TILE - 14, py + TILE - 38, 8, 8);
    ctx.fillStyle = 'white';
    ctx.font = '6px sans-serif';
    ctx.fillText('!', px + TILE - 12, py + TILE - 32);
  }
}

function updateCursorCanvas() {
  cc.clearRect(0, 0, W, H);
  const mx = mouseScreen.x, my = mouseScreen.y;
  const toolCursors = { hand:'‚úã', hoe:'‚õèÔ∏è', water:'üíß', robot_place:'ü§ñ' };
  const seedCursors = { wheat:'üåæ', carrot:'ü•ï', corn:'üåΩ', sunflower:'üåª', potato:'ü•î', tomato:'üçÖ' };
  const icon = toolCursors[currentTool] || seedCursors[currentTool] || '‚úã';
  cc.font = '20px serif';
  cc.fillText(icon, mx - 10, my + 8);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * GAME LOOP
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function update() {
  // Player movement
  let dx = 0, dy = 0;
  if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
  if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
  if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
  if (keys['KeyD'] || keys['ArrowRight']) dx = 1;

  const speed = S.player.speed * TILE / 60;
  const newPx = player.px + dx * speed, newPy = player.py + dy * speed;
  const ntx = Math.floor((newPx + TILE/2) / TILE), nty = Math.floor((newPy + TILE/2) / TILE);

  if (isWalkable(ntx, nty)) {
    player.px = Math.max(0, Math.min(newPx, (WW - 1) * TILE));
    player.py = Math.max(0, Math.min(newPy, (WH - 1) * TILE));
    player.tileX = Math.floor((player.px + TILE/2) / TILE);
    player.tileY = Math.floor((player.py + TILE/2) / TILE);
  }

  player.moving = (dx !== 0 || dy !== 0);
  if (player.moving) {
    if (dx !== 0) player.facingX = dx;
    if (dy !== 0) player.facingY = dy;
    player.frameTimer++;
    if (player.frameTimer > 8) { player.frame = (player.frame + 1) % 4; player.frameTimer = 0; }
  }

  // Space to use tool
  if (keys['Space']) {
    keys['Space'] = false;
    const fx = player.tileX + player.facingX, fy = player.tileY + player.facingY;
    if (inBounds(fx, fy)) handleTileClick(fx, fy, {});
  }

  // Camera follow
  const targetX = W/2 - (player.px + TILE/2) * camera.zoom;
  const targetY = H/2 - (player.py + TILE/2) * camera.zoom;
  const smooth = S.display.cameraSmooth;
  camera.x += (targetX - camera.x) * smooth;
  camera.y += (targetY - camera.y) * smooth;

  // Day/time
  tick++;
  if (tick >= TPDAY) {
    tick = 0; day++;
    const prevSeason = season;
    season = Math.floor((day - 1) / S.time.seasonLength) % SEASONS.length;
    rainDay = Math.random() < (S.time.rainChance[SEASONS[season]] || 0.2);
    refreshPrices();
    saveGame();

    const bannerEl = document.getElementById('day-banner');
    document.getElementById('day-banner-text').textContent = `Day ${day}`;
    document.getElementById('day-banner-sub').textContent = `${SEASONS[season]} ‚Ä¢ ${rainDay ? 'üåß Rainy Day' : '‚òÄÔ∏è Clear Day'}`;
    bannerEl.classList.add('show');
    setTimeout(() => bannerEl.classList.remove('show'), 2500);

    if (season !== prevSeason) notify(`üåø Season changed to ${SEASONS[season]}!`);
    if (rainDay) notify(`üåß It's raining! Crops will be watered today.`);
  }

  updateCrops();
  updateRobots();
  updateParticles();
  updateUI();
  animTime++;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UI
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function updateUI() {
  document.getElementById('stat-coins').textContent = coins;
  document.getElementById('stat-day').textContent = day;
  document.getElementById('stat-season').textContent = SEASONS[season % SEASONS.length];
  const dp = tick / TPDAY;
  const timeName = dp < 0.2 ? 'üåÑ Dawn' : dp < 0.5 ? '‚òÄÔ∏è Day' : dp < 0.7 ? 'üåá Dusk' : 'üåô Night';
  document.getElementById('stat-time').textContent = timeName;

  for (const type of ['wheat','carrot','corn','sunflower','potato']) {
    const el = document.getElementById(`cnt-${type}`);
    if (el) el.textContent = inventory.seeds[type] || '';
  }
}

function selectTool(tool) {
  currentTool = tool;
  document.querySelectorAll('.hslot').forEach(el => el.classList.remove('selected'));
  const el = document.querySelector(`[data-tool="${tool}"]`);
  if (el) el.classList.add('selected');
}

/* ‚îÄ‚îÄ‚îÄ NOTIFICATIONS ‚îÄ‚îÄ‚îÄ */
const notifQueue = [];
function notify(msg) {
  if (!S.display.showNotifications) return;
  const el = document.createElement('div');
  el.className = 'notif';
  el.textContent = msg;
  document.getElementById('notifications').prepend(el);
  setTimeout(() => { el.classList.add('fade'); setTimeout(() => el.remove(), 400); }, S.display.notificationDuration);
}

/* ‚îÄ‚îÄ‚îÄ MODALS ‚îÄ‚îÄ‚îÄ */
function openModal(id) {
  document.querySelectorAll('.modal-overlay').forEach(m => m.classList.add('hidden'));
  document.getElementById(`modal-${id}`).classList.remove('hidden');
  if (id === 'shop') { buildShop(); buildSellGrid(); }
  if (id === 'robots') buildRobotList();
}
function closeModal(id) { document.getElementById(`modal-${id}`).classList.add('hidden'); }
function closeAllModals() { document.querySelectorAll('.modal-overlay').forEach(m => m.classList.add('hidden')); }

function switchTab(modal, tab) {
  const m = document.getElementById(`modal-${modal}`);
  m.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
  m.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
  m.querySelector(`#${modal}-tab-${tab}`)?.classList.add('active');
  const btn = [...m.querySelectorAll('.tab-btn')].find(b => b.textContent.toLowerCase().includes(tab.split('_')[0]));
  if (btn) btn.classList.add('active');
}

/* ‚îÄ‚îÄ‚îÄ SHOP ‚îÄ‚îÄ‚îÄ */
function buildShop() {
  const grid = document.getElementById('seed-shop-grid');
  grid.innerHTML = '';
  for (const [type, cfg] of Object.entries(S.crops)) {
    const price = S.economy.seedPrices[type] || 5;
    const owned = inventory.seeds[type] || 0;
    const el = document.createElement('div');
    el.className = 'shop-item';
    el.innerHTML = `<span class="item-emoji">${cfg.emoji}</span><span class="item-name">${type}</span><span class="item-price">${price} coins/ea</span><span class="item-qty">Owned: ${owned} seeds</span>`;
    el.onclick = (e) => buySeeds(type, e.shiftKey ? 1 : 5);
    grid.appendChild(el);
  }
  document.getElementById('robot-price-display').textContent = `${S.economy.robotCost} coins`;
  document.getElementById('robot-count-display').textContent = `Owned: ${robotsOwned} ‚Ä¢ Placed: ${robots.length}`;
}

function buildSellGrid() {
  const grid = document.getElementById('sell-grid');
  grid.innerHTML = '';
  const hasCrops = Object.entries(inventory.crops).filter(([,v]) => v > 0);
  if (hasCrops.length === 0) {
    grid.innerHTML = '<div style="color:var(--text-dim);font-size:15px;padding:12px">No crops to sell yet. Get farming! üå±</div>';
    return;
  }
  for (const [type, qty] of hasCrops) {
    const cfg = S.crops[type];
    const price = getCropPrice(type);
    const el = document.createElement('div');
    el.className = 'sell-item';
    el.innerHTML = `<span class="item-emoji">${cfg.emoji}</span><div class="sell-info"><div class="name">${type}</div><div class="count">${qty} units ¬∑ ${price} ea</div></div><button class="sell-btn" onclick="sellCrop('${type}')">SELL</button>`;
    grid.appendChild(el);
  }
}

/* ‚îÄ‚îÄ‚îÄ ROBOT LIST ‚îÄ‚îÄ‚îÄ */
let configRobotId = null;

function buildRobotList() {
  const list = document.getElementById('robot-list');
  list.innerHTML = '';
  if (robots.length === 0) {
    list.innerHTML = '<div style="color:var(--text-dim);font-size:15px;padding:12px">No robots placed yet! Buy one at the Shop and place it with the Robot tool (key 9). ü§ñ</div>';
    document.getElementById('robot-config-panel').classList.remove('visible');
    return;
  }
  for (const bot of robots) {
    const bPct = bot.battery / S.robots.batteryMax * 100;
    const el = document.createElement('div');
    el.className = 'robot-list-item' + (bot.id === configRobotId ? ' selected' : '');
    el.innerHTML = `<span class="robot-icon">ü§ñ</span><div class="robot-info"><div class="robot-name">${bot.name} <span style="color:var(--text-dim);font-size:12px">[${bot.behavior}]</span></div><div class="robot-status">${bot.state} ¬∑ ${bot.assignedCrop}</div><div class="battery-bar"><div class="battery-fill ${bPct < 20 ? 'low' : ''}" style="width:${bPct}%"></div></div></div>`;
    el.onclick = () => selectConfigRobot(bot.id);
    list.appendChild(el);
  }

  if (configRobotId || selectedRobotId) {
    const id = configRobotId || selectedRobotId;
    selectConfigRobot(id);
  }
}

function selectConfigRobot(id) {
  configRobotId = id;
  selectedRobotId = id;
  const bot = robots.find(r => r.id === id);
  if (!bot) return;

  const panel = document.getElementById('robot-config-panel');
  panel.classList.add('visible');
  document.getElementById('config-robot-name').textContent = bot.name;

  // Build behavior select
  const bs = document.getElementById('robot-behavior-select');
  bs.innerHTML = '';
  const allB = { ...builtinBehaviors, ...(S.customBehaviors || {}) };
  for (const name of Object.keys(allB)) {
    const opt = document.createElement('option');
    opt.value = name; opt.textContent = name;
    if (name === bot.behavior) opt.selected = true;
    bs.appendChild(opt);
  }

  document.getElementById('robot-crop-select').value = bot.assignedCrop || 'wheat';
  document.getElementById('robot-area-display').textContent = bot.workArea ? `(${bot.workArea.x}, ${bot.workArea.y}) r=${bot.workArea.radius}` : 'Not set';
  document.getElementById('robot-code-editor').value = bot.customCode || '';
  document.getElementById('code-error-msg').textContent = bot.codeError || '';

  document.querySelectorAll('.robot-list-item').forEach((el, i) => {
    el.classList.toggle('selected', robots[i]?.id === id);
  });
}

function applyRobotBehavior() {
  const bot = robots.find(r => r.id === configRobotId);
  if (bot) { bot.behavior = document.getElementById('robot-behavior-select').value; notify(`ü§ñ ${bot.name} behavior: ${bot.behavior}`); }
}

function applyRobotCrop() {
  const bot = robots.find(r => r.id === configRobotId);
  if (bot) { bot.assignedCrop = document.getElementById('robot-crop-select').value; }
}

function saveRobotCode() {
  const bot = robots.find(r => r.id === configRobotId);
  if (!bot) return;
  bot.customCode = document.getElementById('robot-code-editor').value;
  compileRobotCode(bot);
  if (bot.codeError) {
    document.getElementById('code-error-msg').textContent = `‚ùå ${bot.codeError}`;
    notify(`‚ùå Code error in ${bot.name}: ${bot.codeError}`);
  } else {
    document.getElementById('code-error-msg').textContent = '';
    notify(`‚úÖ ${bot.name} custom code saved!`);
  }
}

function clearRobotCode() {
  const bot = robots.find(r => r.id === configRobotId);
  if (!bot) return;
  bot.customCode = ''; bot.compiledCode = null; bot.codeError = '';
  document.getElementById('robot-code-editor').value = '';
  document.getElementById('code-error-msg').textContent = '';
  notify(`üóë ${bot.name} code cleared.`);
}

function deleteSelectedRobot() {
  const idx = robots.findIndex(r => r.id === configRobotId);
  if (idx === -1) return;
  const bot = robots[idx];
  if (!confirm(`Remove ${bot.name}? It will be returned to your inventory.`)) return;
  robotsOwned++; robots.splice(idx, 1);
  configRobotId = null; selectedRobotId = null;
  document.getElementById('robot-config-panel').classList.remove('visible');
  notify(`ü§ñ ${bot.name} returned to inventory.`);
  buildRobotList();
}

function startSetWorkArea() {
  closeAllModals();
  assigningWorkArea = true;
  document.getElementById('assign-overlay').classList.add('visible');
}

function cancelAssign() {
  assigningWorkArea = false;
  document.getElementById('assign-overlay').classList.remove('visible');
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * MAIN GAME LOOP
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * INIT
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
window.addEventListener('resize', resize);
resize();
generateWorld();

const loaded = loadGame();
if (!loaded) {
  notify('üåæ Welcome to Robo Farm! Press F for the guide.');
  notify('üå± Start by tilling soil (key 2) and planting seeds!');
  rainDay = Math.random() < S.time.rainChance['Spring'];
}

// Place starter robots if any
for (let i = 0; i < S.player.startRobots; i++) {
  const bot = new Robot(S.player.startX + 2 + i, S.player.startY + 2);
  robots.push(bot);
}

// Camera init
camera.x = window.innerWidth/2 - (player.px + TILE/2) * camera.zoom;
camera.y = window.innerHeight/2 - (player.py + TILE/2) * camera.zoom;

updateUI();
loop();

/* Click outside modals to close */
document.querySelectorAll('.modal-overlay').forEach(overlay => {
  overlay.addEventListener('click', function(e) {
    if (e.target === this) this.classList.add('hidden');
  });
});
</script>
</body>
</html>
